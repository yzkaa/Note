# 一、串的定义

2020年8月10日

16:12

**串（String）是由零个或多个字符组成的有限序列，又名叫字符串。一般记为s="a1a2……an"（n>=0）**

**串中的字符数目n称为串的长度。零个字符的串称为空串（null string），长度为零。可用希腊字母“Φ”表示。**

**空格串，是只包含空格的串。**

**子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地包含子串的串称为主串。子串在主串中的位置就是子串的以第一个字符在主串中的序号。**

 

# 二、串的比较

2020年8月10日

16:46

**给定两个串s=“a1a2……an”，t=“b1b2......bm”，当满足以下条件之一时，s<t.**

* n<m，且ai=bi（i=1,2,……,n）。

* 存在某个k<=min(m,n)，使得ai=bi（i=1,2,……,k-1），ak<bk。

![img](file:////tmp/wps-yzk/ksohtml/wpsZDtRgi.jpg) 

 

 

 

# 三、串的抽象数据类型

2020年8月11日

11:53

 

![img](file:////tmp/wps-yzk/ksohtml/wpsBMduwl.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps9lidMo.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps5W5Y1r.jpg) 

 

 

 

 

# 四、串的存储结构

2020年8月11日

11:55

## 1.串的顺序存储结构

串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。

![img](file:////tmp/wps-yzk/ksohtml/wpsRkBPhv.jpg) 

串的顺序存储方式有可能在进行两串的连接、新串的插入、以及串的替换操作时溢出。

改变，将串值的存储空间在程序执行过程中动态分配，即在堆区分配空间，使用malloc和free控制大小。

## 2.串的链式存储结构

![img](file:////tmp/wps-yzk/ksohtml/wpsZ3fIxy.jpg) 

 

 

 

# 五、朴素的模式匹配算法

2020年8月11日

12:03

**子串的定位操作通常称作模式匹配**，是串中最重要的操作之一。

简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做子串长度的小循环，直到匹配成功或全部遍历完成为止。

最好情况：一开始就匹配成功，时间复杂度为O(1)。

一般情况：每次都是首字母不匹配，即不进入循环，主串长度为n，子串长度为m，根据等概率原则，查找次数平均（n+m）/2次，时间复杂度为O(m+n)。

最坏情况：每次都是最后一个字符不匹配，时间复杂度为O((n-m+1)*m)。

![img](file:////tmp/wps-yzk/ksohtml/wpsBVmENB.jpg) 

在计算机的运算当中，模式匹配操作随处可见，以上算法效率太低。

 

 

# 六、KMP模式匹配算法

2020年8月11日

12:14

D.E.Knuth和V.R.Pratt共同研究，J.H.Morris独立研究发表了一个模式匹配算法，可以大大避免重复遍历的情况，把它称之为**克努特--莫里斯--普拉特算法，简称KMP算法。**

## 1.KMP模式匹配算法原理

### （1）当子串的字符完全不相等

![img](file:////tmp/wps-yzk/ksohtml/wpsJiSD3E.jpg) 

**如果我们知道子串中首字符与后面的字符均不相等，而子串的第二位与主串中第二位在第一步判断是相等的，那么也就意味着，子串中的第一位与主串中第二位不可能相等，也就不需要判断了，可以跳过，一直到判断不相等的那一位保留**

![img](file:////tmp/wps-yzk/ksohtml/wpsBoZFjI.jpg) 

### （2）当子串中有重复的字符

![img](file:////tmp/wps-yzk/ksohtml/wpsBD9KzL.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsBqYSPO.jpg) 

**因为字串的首位与第四位相等，第二位与第五位相等。在第一步时，第四位与第五位已经与主串中的相应位置比较过相等，因此子串的首字符和第二位与主串中的第四位和第五位不需要比较，肯定是相等的，所以省略**

![img](file:////tmp/wps-yzk/ksohtml/wpsfvz35R.jpg) 

**在朴素模式算法中，主串的i值是不断地回溯来完成的，这种回溯是可以不需要的，好马不吃回头草，KMP模式匹配算法就是为了防止没必要的回溯发生。**

**在KMP算法中，需要变化的是字串的j值，即字串的下标值，如果子串中有相同的字符，那么j值的变化就会不同，所以j值的变化和主串关系不大，关键取决于子串中有没有重复的结构。**

![img](file:////tmp/wps-yzk/ksohtml/wps7aIgmV.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpszNtwCY.jpg) 

**其他情况属于不相等或只有一个字符的情况。** 

**当j=1时，因为需要将主串中的i值加一位，即比较下一个主串元素与子串首元素，且i和j是同时累加，则需要将j置零，进入判断进行累加，当j>1且子串无重复值时，因为前一组肯定是匹配成功的，因为j>1，所以i和j已经同步累加过了，不需要将j置0进入判断。**

## 2.next数值推导

![img](file:////tmp/wps-yzk/ksohtml/wpstuqPS1.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpszg6a94.jpg) 

3.T="ababaaaba"

![img](file:////tmp/wps-yzk/ksohtml/wpsd3TAp8.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsvS23Fb.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps3fAzWe.jpg) 

 

## 3.KMP模式匹配算法实现

 

```c++
#include<iostream>
#include<string>
using namespace std;
 
/*通过计算返回子串T的next数组。*/
void get_next(string T, int* next) {
        int i, j;
        i = 1;
        j = 0;
        next[1] = 0;
        while (i < T[0]) {/*此处T[0]表示串T的长度*/
                if (j == 0 || T[i] == T[j]) {
                        ++i;
                        ++j;
                        next[i] = j;
                }
                else
                        j = next[j];/*若字符不相同，则j值回溯*/
        }
}
 
/*返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0*/
/*T非空，1<=pos<=StrLength(S)*/
int Index_KMP(string S, string T, int pos) {
        int i = pos;/*i用于主串S当前位置下标，若pos不为1则从pos位置开始匹配*/
        int j = 1;/*j用于子串T中当前位置下标值*/
        int next[255];/*定义一next数组*/
        get_next(T, next);
        while (i <= S[0] && j <= T[0]) {
                if (j == 0 || S[i] == T[j]) {/*两字母相等则继续，相比于朴素算法增加了j=0判断*/
                        ++i;
                        ++j;
                }
                else {/*指针后退重新开始匹配*/
                        j = next[j];/*j返回合适的位置，i值不变*/
                }
        }
        if (j > T[0]) {
                return i - T[0];
        }
        else {
                return 0;
        }
}
```

 

## 4.KMP模式匹配算法改进

![img](file:////tmp/wps-yzk/ksohtml/wpsxVMsKo.jpg)  

![img](file:////tmp/wps-yzk/ksohtml/wpsBnxi1r.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsvXZaiv.jpg) 

 

```c++
/*改进get_nextval 求模式串T的next函数修正值并存入数组nexval*/
void get_nextval(string T, int* nextval) {
        int i, j;
        i = 1;
        j = 0;
        nextval[1] = 0;
        while (i < T[0]) {
                if (j == 0 || T[i] == T[j]) {
                        ++i;
                        ++j;
                        if (T[i] != T[j]) {/*若当前字符与前缀字符不同*/
                                nextval[i] = j;/*则当前的j为nextval在i位置的值*/
                        }
                        else {
                                nextval[i] = nextval[j];/*如果与前缀字符相同，则将前缀字符的nextval值赋值给nextval在i位置的值*/
                        }
                }
                else {
                        j = nextval[j];
                }
        }
}
```

注释位置为改良部分

 

## 5.nextval数组值推导

**改良后，nextval值就与next值不完全相同了。**

![img](file:////tmp/wps-yzk/ksohtml/wps1P7dzy.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsjZMkQB.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsHXEu7E.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsxnHHoI.jpg) 

 

 

 

 

 

 

# 七、总结

2020年8月11日

19:50

串是由零个或多个字符组成的有限序列，又名叫字符串。本质上它是一种线性的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。