# 感知机（perceptron）

​		感知机接受多个输入信号，输出一个信号，输入信号被送往神经元时，会被分别乘固定的权重，神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为神经元被激活，界限值称为**阈值**。

​		权重越大，对应该权重的信号的重要性就越大。

```python
def AND(x1,x2):
    w1,w2,theta = 0.5,0.5,0.7
    tmp = x1*w1 +x2*w2
    if tmp <= theta:
        return 0
    elif tmp > theta:
        return 1
```

导入权重和偏置

```python
#导入权重和偏置
import numpy as np
x = np.array([0,1]) #输入
w = np.array([0.5,0.5]) #权重
b = -0.7    #偏置
np.sum(w*x)+b
```

使用权重和偏置实现与门

```python
#使用权重和偏置实现与门
def AND1(x1,x2):
    x = np.array([x1,x2]) #输入
    w = np.array([0.5,0.5]) #权重
    b = -0.7    #偏置
    tmp = np.sum(w*x)+b
    if tmp <=0:
        return 0
    else:
        return 1
```

**权重是控制输入信号的重要性的参数，而偏置是调整神经元被激活的容易程度的参数。**

```python
#单层与非门 与 或门
def NAND(x1,x2):
    x = np.array([x1,x2]) #输入
    w = np.array([-0.5,-0.5]) #权重
    b = 0.7    #偏置
    tmp = np.sum(w*x) + b
    if tmp <=0:
        return 0
    else:
        return 1

def OR(x1,x2):
    x = np.array([x1,x2]) #输入
    w = np.array([0.5,0.5]) #权重
    b = -0.2    #偏置
    tmp = np.sum(w*x) + b
    if tmp <=0:
        return 0
    else:
        return 1
```

## 感知机的局限性

异或门（XOR gate）被称为逻辑异或电路。异或门无法用单层感知机实现。单层感知机只能表示线性空间，非线性空间无法分离。但可以通过**叠加层**来实现异或。

```PYTHON
#使用感知机叠加层实现异或
def XOR(x1,x2):
    s1 = NAND (x1,x2)
    s2 = OR (x1,x2)
    y = AND (s1,s2)
    return y
print(XOR(1,1))
```

感知机叠加后变成非线性，叠加了多层的感知机也称为多层感知机（muyil-layered perceptron）。相当于多个神经元协同作用。第0层的两个神经元接收输入信号，将信号发送至第一层的神经元，第一层的神经元发送至第二层的神经元，第二层的神经元输出结果。

计算机和感知机一样，也有输入和输出，会按照某个既定的规则进行计算。可以用感知机表示计算机。

# 神经网络

神经网络最左边一层称为**输入层**（第0层），最右边的一列称为**输出层** （第2层），中间的一列称为**中间层**（第1层），**也成为隐藏层**。 

**激活函数**（activation function）会将输入信号的总和转换为输出信号，作用在于决定如何来激活输入信号的总和。

一般而言，朴素感知机是指单层网络，指的是激活函数使用了阶跃函数的模型。多层感知机指的是神经网络，即使用sigmoid函数等平滑的激活函数的多层网络。

## sigmoid函数

神经网络中经常使用的一种激活函数。 

```python
#阶跃函数的实现
def step_function(x):
    if x>0:
        return 1
    else:
        return 0
```

上述实现简单、易于理解，但是参数x只能接受实数。

```python
#新实现
def step_function1(x):
    y = x >0
    return y.astype(np.int)
```

先进行不等运算变为bool值，再将其转换为int

阶跃函数的图形

```python
import numpy as np
import matplotlib.pylab as plt

def step_function1(x):
    return np.array(x>0,dtype=np.int)

x = np.arange(-5.0,5.0,0.1)
y = step_function1(x)
plt.plot(x,y)
plt.ylim(-0.1,1.1) #指定y轴范围
plt.show()
```

呈阶梯式变化

sigmoid的实现

```python
#sigmoid函数的实现
def sigmoid(x):
    return 1/(1+np.exp(-x))
```

