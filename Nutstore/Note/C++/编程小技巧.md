# 1.不使用判断函数比较大小

max = ((a+b)+abs(a-b))/2;

min = ((a+b)-abs(a-b))/2;



# 2.判断数字是否为2的幂次

```c++
bool isPowerOf2 (int num){
	return (num!=0)&&((num & -num) ==num);
}
```

# 3.判断数字是否为偶数

```c++
bool isEvenNumber(int num){
	return (num & 1) ==0;
}
```

# 4.关于typedef

```c++
#include <iostream> 

typedef long long ll;

void foo(unsigned ll) {
    std::cout << "1";
}

void foo(unsigned long long) {
    std::cout << "2";
}

int main() {
    foo(2ull);	//结果是2
}
```

ll被当成了一个参数名而不是long long，unsigned实际上是unsigned int



# 5.关于namespace

```c++
#include <iostream>

namespace x {
  class C {};
  void f(const C& i) {
    std::cout << "1";
  }
}

namespace y {
  void f(const x::C& i) {
    std::cout << "2";
  }
}

int main() {
  f(x::C());//输出1
}

```

由于函数定义在命名空间内，且为非限定调用，所以一般不会通过，但是Koenig lookup中定义了这样是正确的，使用参数相关名称查找，函数参数的名称空间将添加到要搜索该函数的名称空间集中。因为我们将x:：C传递给f，所以也会搜索名称空间x，并找到函数x:：f。

# 6.关于C地址

连续定义的两个同类型数组，其地址分布和一个数组一样，从低到高进行分配。