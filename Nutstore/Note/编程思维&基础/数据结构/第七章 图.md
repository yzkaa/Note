# 一、图的定义

2020年8月14日

22:16

**图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V,E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。**

 

需要明确注意的地方：

线性表中我们把数据元素叫做元素，树中将数据元素叫结点，在**图中数据元素，我们称之为顶点（Vertex）。**

线性表中可以没有数据元素，称为空表，树中可以没有结点，叫做空树。在图结构中，不允许没有顶点，强调顶点集合的有穷非空。

线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，**任意两个顶点之间都可能有关系，顶点之家的逻辑关系用边表示，边的集合可以为空。**

## 1.各种图定义

**无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对（vi，vj）来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）。**

![img](file:////tmp/wps-yzk/ksohtml/wpsdDZeex.jpg) 

**（A,D）或（D,A）**

![img](file:////tmp/wps-yzk/ksohtml/wps3QMQ2i.jpg) 

 

**有向边：若顶点vi到vj的边有方向，则称这条边为有向边，也称为弧（Arc）。用有序偶<vi，vj>来表示，vi称为弧尾（Tail），vj称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。**

![img](file:////tmp/wps-yzk/ksohtml/wpsfhuvR4.jpg) 

**连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，<A，D>表示弧，注意不能写成<D，A>。**

![img](file:////tmp/wps-yzk/ksohtml/wpsFdscGQ.jpg) 

**在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。**

![img](file:////tmp/wps-yzk/ksohtml/wpsDMnVuC.jpg) 

**以上图不属于简单图。**

**在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n\*（n-1）/2条边。**

![img](file:////tmp/wps-yzk/ksohtml/wpsrCvGjo.jpg) 

**在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n*（n-1）条边。**

![img](file:////tmp/wps-yzk/ksohtml/wps1tAt89.jpg) 

**有很少条边或弧的图称为稀疏图，反之称为稠密图。**

**有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。这些权可以表示一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网（Network）。**

![img](file:////tmp/wps-yzk/ksohtml/wpspeNiXV.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsNvO9LH.jpg) 

例如下图带底纹的图均为左侧无向图与有向图的子图。

![img](file:////tmp/wps-yzk/ksohtml/wpspuV2At.jpg) 

## 2.图的顶点与边间关系

![img](file:////tmp/wps-yzk/ksohtml/wpsPKcZpf.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpshAMXe1.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsrB6X3M.jpg) 

**各顶点的入度和等于个顶点的出度和。**

![img](file:////tmp/wps-yzk/ksohtml/wpslxM0Sy.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsLNE5Hk.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsHKFcx6.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsb0olmS.jpg) 

**路径的长度是路径上的边或弧的数目。**

**第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。**

![img](file:////tmp/wps-yzk/ksohtml/wpsNfewbE.jpg) 

## 3.连通图相关术语

**在无向图G中，如果从顶点v到顶点v\`有路径，则称v和v\`是连通的。如果对于图中任意两个顶点vi，vj∈E，vi和vj都是连通的，则称G是连通图（Connected Graph）。**

![img](file:////tmp/wps-yzk/ksohtml/wpsz1NJ0p.jpg) 

**左图不是连通图，右图是连通图。**

**无向图中的极大连通子图称为连通分量。强调**

**要是子图；**

**子图要是连通的；**

**连通子图含有极大顶点数；**

**具有极大顶点数的连通子图包含依附于这些顶点的所有边。**

 

**在有向图G中，如果对于每一对vi，vj∈V，vi不等于vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。**

![img](file:////tmp/wps-yzk/ksohtml/wpsNzq0Pb.jpg) 

**左图不是强连通图，右图是强连通图，右图是左图的极大连通子图，即右图是左图的强连通分量。**

 

**所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。有n-1条边并不一定生成树。**

**如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1条边，必定构成一个环。**

 

![img](file:////tmp/wps-yzk/ksohtml/wpsJzxjFX.jpg) 

**图1和图4不是生成树，图2，3是生成树。**

**如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。入度为0相当于树的根结点，其余入度为1就是说树的非根结点的双亲只有一个。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。**

![img](file:////tmp/wps-yzk/ksohtml/wpsPOAFuJ.jpg) 

**如图1是有向图，图2,3是图1的生成森林。**

**4.图的定义与术语总结**

**图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图有顶点和弧构成。弧有弧头和弧尾之分。**

**图按照边或弧的多少分为稀疏图和稠密图。如果任意两个顶点之间都存在边或弧叫完全图或有向完全图，若无重复的边或顶点到自身的边则叫简单图。**

**图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。**

**图上的边或弧上带权则称为网。**

**图中顶点间存在路径，两定点存在路径则说明连通，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则为连通分量，有向的称强连通分量。**

**无向图中连通且n个顶点n-1条边叫生成树。有向图中以顶点入度为0，其余项点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。**

 

 

 

# 二、图的抽象数据类型

2020年9月2日

10:34

![img](file:////tmp/wps-yzk/ksohtml/wpsz0O5jv.jpg) 

 

 

# 三、图的存储结构

2020年9月2日

10:39

## 1.邻接矩阵

**图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。**

![img](file:////tmp/wps-yzk/ksohtml/wpsNT6B9g.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsNzjaZ2.jpg) 

**有了这个矩阵，**

**我们要判定任意两顶点是否有边无边就非常容易了。**

**我们要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行（或第i列）的元素之和。比如顶点v1的度就是1+0+1+0=2。**

**求顶点vi\的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点。**

 

 

有向图样例：

![img](file:////tmp/wps-yzk/ksohtml/wpsPtkLOO.jpg) 

设G是网图，有n个顶点，则邻接矩阵是一个nxn的方阵，定义为：

![img](file:////tmp/wps-yzk/ksohtml/wpslaAoEA.jpg) 

Wij表示（vi，vj）或<vi，vj>上的权值，Wij大多数情况下是正值，但个别时候可能就是0，甚至有可能不存在。

![img](file:////tmp/wps-yzk/ksohtml/wpsDqX3tm.jpg) 

```c++
#include<iostream>
#include<stdio.h>
using namespace std;
/*图结构定义*/
typedef char VertexType;/*定点类型应由用户定义*/
typedef int EdgeType;/*边的权值类型应由用户定义*/
constexpr auto MAXVEX = 100;/*最大顶点数，应由用户定义*/
constexpr auto INFINTY = 65535;/*用65535来代表不存在*/
typedef struct {
        VertexType vexs[MAXVEX];/*顶点表*/
        EdgeType arc[MAXVEX][MAXVEX];/*邻接矩阵，可看作边表*/
        int numVertexes, numEdges;/*图中当前的顶点数和边数*/
}MGraph;
 
/*建立无向网图的邻接矩阵表示*/
void CreateMGraph(MGraph *G) {
        int i, j, k, w;
        cout << "输入顶点数和边数" << endl;
        //cin >> G->numVertexes >> G->numEdges;
        scanf("%d,%d", &G->numVertexes, &G->numEdges);/*输入顶点和边数*/
        for (i = 0; i < G->numVertexes; i++) {
                cin >> G->vexs[i];
        }
        for (i = 0; i < G->numVertexes; i++) {
                for (j = 0; j < G->numVertexes; j++) {
                        G->arc[i][j] = INFINITY;/*邻接矩阵初始化*/
                }
        }
        for (k = 0; k < G->numEdges; k++) {
                cout << "输入边（vi，vj）上的下标i，下标j和权w" << endl;
                cin >> i >> j >> w;/*输入边（vi，vj）上的权w*/
                G->arc[i][j] = w;
                G->arc[i][j] = G->arc[j][i];/*因为是无向图，矩阵对称*/
        }
}
```



从代码可知，n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n²+e)，其中对邻接矩阵G，arc的初始化耗费了O（n²）的时间。

 

## 2.邻接表

**对于边数相对顶点较少的图，邻接矩阵对存储空间浪费极大。**

![img](file:////tmp/wps-yzk/ksohtml/wpsnwX0j8.jpg) 

**考虑另一种存储结构方式，考虑对边或弧使用链式存储的方式来避免空间浪费的问题。**

**树中的孩子表示法同样适用于图的存储。我们把数组与链表相结合的存储方法称为邻接表（Adjacency List）。**

**邻接表的处理方法：**

**图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。**

**图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。**

![img](file:////tmp/wps-yzk/ksohtml/wpszXI09T.jpg) 

**由图可知，data是数据域，firstedge是指针域，指向边表的第一个结点。边表结点由adjvex和next两个域组成。\adjvex\是邻接点域，存储某定点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。**

 

**有向图的邻接表结构类似，一般以弧尾来存储边表，但有时为了便于确定顶点的入度或以顶点为弧头的弧，可以建立一个有向图的逆邻接表，以弧头来存储边表。**

![img](file:////tmp/wps-yzk/ksohtml/wpsnGF3ZF.jpg) 

**对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。**

![img](file:////tmp/wps-yzk/ksohtml/wpsVXi9Pr.jpg) 

```c++
/*邻接表*/
typedef        char VertexType;
typedef int EdgeType;
 
typedef struct EdgeNode {
        int adjvex;/*邻接点域，存储该顶点对应的下标*/
        EdgeType weight;/*用于存储权值，对于非网图可以不需要*/
        struct EdgeNode* next;/*链域，指向下一个邻接点*/
}EdgeNode;
 
typedef struct VertexNode {/*顶点表结点*/
        VertexType data;/*顶点域，存储顶点信息*/
        EdgeNode* firstedge;/*边表头指针*/
}VertexNode,AdjList[MAXVEX];
 
typedef struct {
        AdjList adjList;
        int numVertexes, numEdges;/*图中当前顶点数和边数*/
}GraphAdjList;
 
/*建立图的邻接表结构*/
void CreateALGraph(GraphAdjList* G) {
        int i, j, k;
        EdgeNode* e;
        cout << "输入顶点数和边数" << endl;
        cin >> G->numVertexes >> G->numEdges;/*输入顶点数和边数*/
        for (i = 0; i < G->numVertexes; i++) {/*读入顶点信息，建立顶点表*/
                cin >> G->adjList[i].data;/*输入顶点信息*/
                G->adjList[i].firstedge = NULL;/*将边表置为空表*/
        }
        for (k = 0; k < G->numEdges; k++) {
                cout << "输入边（vi，vj）上的顶点序号" << endl;
                cin >> i >> j;/*输入边（vi，vj）上的顶点序号*/
                e = (EdgeNode*)malloc(sizeof(EdgeNode));/*向内存申请空间，生成边表结点*/
                e->adjvex = j;/*邻接序号为j*/
                e->next = G->adjList[i].firstedge;/*将e指针指向当前顶点指向的结点*/
                G->adjList[i].firstedge = e;/*将当前顶点的指针指向e*/
                e = (EdgeNode*)malloc(sizeof(EdgeNode));/*像内存申请空间，生成边表结点*/
                e->adjvex = i;/*邻接序号为i*/
                e->next = G->adjList[j].firstedge;/*将e指针指向当前顶点指向的结点*/
                G->adjList[j].firstedge = e;/*将当前顶点的指针指向e*/
        }
}
```



**代码应用了单链表中的头插法。本算法的时间复杂度对于n个顶点e条边来说，为O(n+e)。**

 

## 3.十字链表（Orthogonal List）

**对于有向图来说，邻接表是有缺陷的，关心了出度问题，想了解入度就必须遍历整个图。**

**十字链表能把邻接表与逆邻接表结合起来。**

![img](file:////tmp/wps-yzk/ksohtml/wpslo5tGd.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsdHJQwZ.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsJckfnL.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsx2PFdx.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsfuG83i.jpg) 

**虚线其实就是此图的逆邻接表的表示。对于v0来说，它有两个顶点v1和v2的入边，因此v0的firsttin指向顶点v1的边表结点中headvex为0的结点。如虚线1。接着由入边结点的headlink指向下一个入边顶点v2，如图中的虚线2。对于顶点v1，它有一个入边顶点v2，所以它的firstin\*******\*指向定点v2的边表结点中headvex为1的结点，如图中的虚线3。顶点v2和v3也是同样有一个入边顶点，如图中虚线4和5。**

**十字链表创建图算法的时间复杂度是和邻接表相同的。因此在有向图的应用中，十字链表是非常好的数据结构模型。**

## 4.邻接多重表

**无向图的优化**

![img](file:////tmp/wps-yzk/ksohtml/wpsNCDFU4.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsvaOeLQ.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsJa9PBC.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsZBHtso.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpst9g9ia.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps98lR9V.jpg) 

**邻接多重表与邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。**

**5.边集数组**

**边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下表（begin）、终点下标（end）和权（weight）组成。边集数组关注的是边的集合。**

![img](file:////tmp/wps-yzk/ksohtml/wpsVKeC0H.jpg) 

 

 

 

# 四、图的遍历

2020年9月4日

11:30

**图的遍历和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Taversing Graph）。**

 

**通常有两种遍历次序方案：深度优先遍历和广度优先遍历。**

 

## 1.深度优先遍历（Depth_First_Search）
也有称为深度优先搜索，简称为DFS。是一个递归的过程。

**它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。**

![img](file:////tmp/wps-yzk/ksohtml/wpsZhXqRt.jpg) 

对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，**若图中尚有顶点未被访问，则另选同种一个未曾被访问的顶点做起始点，重复上述过程，直至图中所有顶点都被访问到为止。**

 

**如果我们用的是邻接矩阵的方式**

typedef int Boolean;Boolean visited[MAXVEX];/*邻接矩阵的深度优先递归算法*/void DFS(MGraph G, int i) {    int j;    visited[i] = 1;    cout << G.vexs[i];/*打印顶点，也可以其他操作*/    for (j = 0; j < G.numVertexes; j++) {        if (G.arc[i][j] ==1 && !visited[j]){/*判断边存在且未访问*/            DFS(G, j);/*对未访问的邻接顶点递归调用*/        }    }}/*邻接矩阵的深度遍历操作*/void DFSTraverse(MGraph G) {    int i;    for (i = 0; i < G.numVertexes; i++) {        visited[i] = 0;/*初始化所有顶点*/    }    for (i = 0; i < G.numVertexes; i++) 

```c++
typedef int Boolean;
Boolean visited[MAXVEX];
/*邻接矩阵的深度优先递归算法*/
void DFS(MGraph G, int i) {
        int j;
        visited[i] = 1;
        cout << G.vexs[i];/*打印顶点，也可以其他操作*/
        for (j = 0; j < G.numVertexes; j++) {
                if (G.arc[i][j] ==1 && !visited[j]){/*判断边存在且未访问*/
                        DFS(G, j);/*对未访问的邻接顶点递归调用*/
                }
        }
}
/*邻接矩阵的深度遍历操作*/
void DFSTraverse(MGraph G) {
        int i;
        for (i = 0; i < G.numVertexes; i++) {
                visited[i] = 0;/*初始化所有顶点*/
        }
        for (i = 0; i < G.numVertexes; i++) {
                if (!visited[i]) {/*对未访问过的顶点调用DFS，若是连通图，只会执行一次*/
                        DFS(G, i);
                }
        }
}
```

**如果图结构是邻接表结构**

```c++
/*邻接表的深度优先递归算法*/
void DFS(GraphAdjList *GL, int i) {
        EdgeNode* p;
        visited[i] = 1;
        cout << GL->adjList[i].data;/*打印顶点，也可以其他操作*/
        p = GL->adjList[i].firstedge;
        while (p) {
                if (!visited[p->adjvex]) {
                        DFS(GL, p->adjvex);/*对未访问的邻接顶点递归调用*/
                }
                p = p->next;
        }
}
/*邻接表的深度遍历操作*/
void DFSTraverse(GraphAdjList *GL) {
        int i;
        for (i = 0; i < GL->numVertexes; i++) {
                visited[i] = 0;/*初始化所有顶点状态为未访问*/
        }
        for (i = 0; i < GL->numVertexes; i++) {
                if (!visited[i]) {/*对未访问过的顶点调用DFS,若是连通图，只会执行一次*/
                        DFS(GL, i);
                }
        }
}
```



**对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此需要O(n²)的时间。**

**而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。**

## 2.广度优先遍历（Breadth_First_Search）

**又称为广度优先搜索。简称BFS。** 

![img](file:////tmp/wps-yzk/ksohtml/wpsDsZxIf.jpg) 

```c++
/*邻接矩阵的广度遍历算法*/
void BFSTraverse(MGraph G) {
        int i, j;
        Queue Q;/*辅助用队列*/
        for (i = 0; i < G.numVertexes; i++) {
                visited[i] = 0;
        }
        InitQueue(&Q);/*初始化一辅助用队列*/
        for (i = 0; i < G.numVertexes; i++) {/*对每一个顶点做循环*/
                if (!visited[i]) {/*若是未访问过就处理*/
                        visited[i] = 1;/*设置当前顶点访问过*/
                        cout << G.vexs[i];/*打印顶点，也可以其他操作*/
                        EnQueue(&Q,i)/*将此顶点入队列*/
                        while (!Q.empty()) {
                                DeQueue(&Q, &i);/*将队中元素出队列，赋值给i*/
                                for (j = 0; j < G.numVertexes; j++) {
                                        /*判断其他顶点若与当前顶点存在边且未访问过*/
                                        if (G.arc[i][j] == 1 && !visited[j]) {
                                                visited[j] = 1;/*将找到的此顶点标记为已访问过*/
                                                cout << G.vexs[j];/*打印顶点*/
                                                EnQueue(&Q, j);/*将找到的此顶点入队列*/
                                        }
                                }
                        }
                }
        }
}
```

在时间复杂度上DFS和BFS是一样的，不同之处仅仅在于对顶点访问的顺序不同。视情况不同而选择合适的算法。

**深度优先更适合目标比较明确，已找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。**



# 五、最小生成树

2020年9月5日

19:36

 

 

![img](file:////tmp/wps-yzk/ksohtml/wps1pBCiz.jpg) 

**我们把构造连通网最小代价生成树称为最小生成树（Minimum Cost Spanning Tree）。**

## **1.普里姆（Prim）算法**

![img](file:////tmp/wps-yzk/ksohtml/wps7TK39k.jpg) 

```c++
/*Prim算法生成最小生成树*/
void MiniSpanTree_Prim(MGraph G) {
        int min, i, j, k;
        int adjvex[MAXVEX];/*保存相关顶点下标*/
        int lowcost[MAXVEX];/*保存相关顶点间边的权值*/
        lowcost[0] = 0;/*初始化第一个权值为0，即v0加入生成树*/
        /*lowcost的值为0，在这里就是此下标的顶点已经加入生成树*/
        adjvex[0] = 0;/*初始化第一个顶点下标为0*/
        for (i = 1; i < G.numVertexes; i++) {//循环除下标为0外的全部顶点
                lowcost[i] = G.arc[0][i];/*将v0顶点与之有边的权值存入数组*/
                adjvex[i] = 0;/*初始化都为vo的下标*/
        }
        for (i = 1; i < G.numVertexes; i++) {
                min = INFINITY;/*初始化最小权值为无穷，通常设置为不可能的大数字*/
                j = 1; k = 0;
                while (j < G.numVertexes) {
                        if (lowcost[j] != 0 && lowcost[j < min]) {
                                /*如果权值不为0且权值小于min*/
                                min = lowcost[j];/*则让当前权值成为最小值*/
                                k = j;/*让当前最小值的下标存入k*/
                        }
                        j++;
                }
                cout << adjvex[k] << k;/*打印当前顶点边中权值最小边*/
                lowcost[k] = 0;/*将当前顶点的权值设置为0，表示此顶点已经完成任务*/
                for (j = 1; j < G.numVertexes; j++) {
                        if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j]) {
                                /*若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值*/
                                lowcost[j] = G.arc[k][j];/*将较小权值存入lowcost*/
                                adjvex[j] = k;/*将下标为k的顶点存入adjvex*/
                        }
                }
        }
}
```

 

![img](file:////tmp/wps-yzk/ksohtml/wpshFkL16.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsdXdwTS.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsPlJkLE.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsrAKcDq.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps3qL7uc.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsHQ35mY.jpg) 

## 2.克鲁斯卡尔（Kruskal）算法

**以边为目标构建。用到图的存储结构中的边集数组结构edge。**

![img](file:////tmp/wps-yzk/ksohtml/wpsfcx7eK.jpg) 

```c++
/*对边集数组Edge结构的定义*/
typedef struct {
        int begin;
        int end;
        int weight;
}Edge;
/*Kruskal算法生成最小生成树*/
constexpr auto MAXEDGE = 15;/*边数量最大值*/
void MiniSpanTree_Kruskal(MGraph G) {/*生成最小生成树*/
        int i, n, m;
        Edge edges[MAXEDGE];/*定义边集数组*/
        int parent[MAXVEX];/*定义一数组用来判断边与边是否形成环路*/
        /*此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码*/
        for (i = 0; i < G.numEdges; i++) {
                parent[i] = 0;/*初始化数组为0*/
        }
        for (i = 0; i < G.numEdges; i++) {
                n = Find(parent, edges[i].begin);
                m = Find(parent, edges[i].end);
                if (n != m) {/*假如n与m不等，说明此边没有与现有生成树形成环路*/
                        parent[n] = m;/*将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中*/
                        cout << edges[i].begin << edges[i].end << edges[i].weight << endl;
                }
        }
}
 
int Find(int* parent, int f) {
        while (parent[f] > 0) {
                f = parent[f];
        }
        return f;
}
```

 

![img](file:////tmp/wps-yzk/ksohtml/wpszxon7v.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsbDrIZh.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsJ3N6R3.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpshXxxKP.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsZnF1CB.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsTSOyvn.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsTTA9n9.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsnFAMgV.jpg) 

 

 

 

# 六、最短路径

2020年9月8日

20:23

**对于网图来说，最短路径是指两定点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。**

![img](file:////tmp/wps-yzk/ksohtml/wps3Yat9G.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsFLTb2s.jpg) 

## 1.迪杰斯特拉（Dijkstra）算法

**按路径长度递增的次序产生最短路径的算法**

```c++
constexpr auto MAXVEX = 9;
typedef int Pathmatirx[MAXVEX];/*用于存储最短路径下标的数组*/
typedef int ShortPathTable[MAXVEX];/*用于存储到各点的最短路径的权值和*/
/*Dijkstra算法，求有向网G的v0顶点到其余顶点v最短路径P[v]及带权长度D[v]*/
/*P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和*/
void ShortestPath_Dijkstra(MGraph G, int v0, Pathmatirx* p, ShortPathTable* D) {
        int v, w, k, min;
        int final[MAXVEX];/*final[w]=1表示求得顶点v0至vw的最短路径*/
 
        for (v = 0; v < G.numVertexes; v++)/*初始化数据*/ {
                final[v] = 0;/*全部定点初始化为位置最短路径状态*/
                (*D)[v] = G.matirx[v0][v];/*将与v0有连线的顶点加上权值*/
                (*p)[v] = 0;/*初始化路径数组P为0*/
        }
        (*D)[v0] = 0;/*v0至v0路径为0*/
        final[v0] = 1;/*v0至v0不需要求路径*/
        /*开始主循环，每次求得v0到某个v顶点的最短路径*/
        for (v = 1; v < G.numVertexes; v++) {
                min = INFINITY; /*当前所知离v0到某个顶点的最短路径*/
                for (w = 0; w < G.numVertexes; w++)/*寻找离v0最近的顶点*/ {
                        if (!final[w] && (*D)[w] < min) {
                                k = w;
                                min = (*D)[w]; /*w顶点离v0顶点更近*/
                        }
                }
                final[k] = 1;/*将目前找到的最近的顶点置位1*/
                for (w = 0; w < G.numVertexes; w++)/*修正当前最短路径及距离*/ {
                        /*如果经过b顶点的路径比现在这条路径的长度短的话*/
                        if (!final[w] && (min + G.matirx[k][w] < (*D)[w])) {
                                /*说明找到了更短的路径，修改D[w]和P[w]*/
                                (*D)[w] = min + G.matirx[k][w];/*修改当前路径长度*/
                                (*p)[w] = k;
                        }
                }
        }
}
```

**时间复杂度为O(n²)，如果我们还需要知道任一顶点到其余所有顶点的最短路径，将再来一次循环，时间复杂度为O(n³)。**

 

 

## 2.弗洛伊德（Floyd）算法

![img](file:////tmp/wps-yzk/ksohtml/wpsXXaeVe.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsjaFjO0.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsjbGtHM.jpg) 

 

因为是求所有顶点到所有顶点的最短路径，所以P和D都是二维数组。

```c++
typedef int Pathmatirx[MAXVEX][MAXVEX];
     typedef int ShortPathTable[MAXVEX][MAXVEX];
     /*Floyd算法，求网图G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]*/
     void ShortestPatth_Floyed(MGraph G, Pathmatirx* P, ShortPathTable* D) {
         int v, w, k;
         for (v = 0; v < G.numVertexes; ++v) {/*初始化D与P*/
             for (w = 0; w < G.numVertexes; ++w) {
                 (*D)[v][w] = G.matirx[v][w];/*D[v][w]值即为对应点间的权值*/
                 (*P)[v][w] = w;/*初始化P*/
            }
        }
    
        for (k = 0; k < G.numVertexes; ++k) {
            for (v = 0; v < G.numVertexes; ++v) {
                for (w = 0; w < G.numVertexes; ++w) {
                    if ((*D)[v][w] > (*D)[v][k] + (*D)[k][w]) {
                        /*如果经过下标为k顶点路径比原两点间路径更短*/
                        /*将当前两点间权值设为更小的一个*/
                       (*D)[v][w] = (*D)[v][k] + (*D)[k][w];
                        (*P)[v][w] = (*P)[v][k];/*路径设置经过下标为l的顶点*/
                    }
                }
            }
```

![img](file:////tmp/wps-yzk/ksohtml/wpsBqpPAy.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsLdDeuk.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsFaXGn6.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps1gxchS.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsZCQMaE.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsVaKr4p.jpg) 

 

 

如果要求最短路径，可以这样求：

```c++
  /*求最短路径*/

     for (v = 0; v < G.numVertexes; ++v) {

       for (w = v + 1; w < G.numVertexes; w++) {

         cout << "v" << v << "-" << "v" << w << "\tweight:" << D[v][w] << endl;

         k = *P[v][w];/*获得第一个路径点的下标*/

         cout << "path:" << v << endl;/*打印源点*/

         while (k != w) {/*如果路径顶点下标不是终点*/

           cout << "->" << k;/*打印路径顶点*/

           k = *P[k][w];/*获得下一个路径顶点下标*/

         }

         cout << "->" << w << endl;/*打印终点*/

       }

       cout << endl;
	} 
```

 

**Floyed算法的时间复杂度为O（n³）。如果面临需要求所有顶点至所有顶点的最短路径问题时，Floyed算法应该是不错的选择。**

虽然求最短路径的两个算法举例都是无向图，但是它们对于有向图依然有效，具体看《算法导论》。

 

 

# 七、拓扑排序

Tuesday, October 6, 2020

3:07 PM

 

## 1.拓扑排序介绍

**在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。AOV网中的弧表示活动之间存在的某种制约关系。AOV网中不能存在回路。**

![img](file:////tmp/wps-yzk/ksohtml/wpsPvQeYb.jpg) 

**设G=（V,E）是一个具有n个顶点的有向图，V中的顶点序列v1,v2,……,vn满足从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前。则我们成这样的顶点序列为一个拓扑序列。**

**所谓拓扑排序，其实就是一个对有向图构造拓扑序列的过程。**

**构造时，如果此网的全部顶点都被输出，则说明它是不存在回环的AOV网；如果输出的顶点少了，说明这个网不是AOV网，存在回环。**

 

## 2.拓扑排序算法

**基本思路：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。**

**为AOV网建立一个邻接表，在邻接表中增加一个入度域in。**

![img](file:////tmp/wps-yzk/ksohtml/wpsXH65RX.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsVkkZLJ.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsLHxVFv.jpg) 

 

在算法中，还需要使用栈来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找入度为0的顶点。

  

```c++
 typedef struct EdgeNode {/*边表结点*/
     int adjvex;/*邻接点域，存储该顶点对应的下标*/
     int weight;/*用于存储权值，对于非网图可以不需要*/
     struct EdgeNode* next;/*链域，指向下一个邻接点*/
   }EdgeNode;
   
   typedef struct VertxNode {/*顶点表结点*/
     int in;/*顶点入度*/
     int data;/*顶点域，存储顶点信息*/
     EdgeNode* firstedge;/*边表头指针*/
   }VertexNode,AdjList[MAXVEX];
   
   typedef struct {
     AdjList adjList;
     int numVertexes, numEdges;/*图中当前顶点数和边数*/
   }GraphAdjList,*GraphAdjList;

   /*拓扑排序，若GL无回路，则输出拓扑排序序列斌返回OK，若有回路则返回ERROR*/
   bool TopologicalSort(GraphAdjList GL) {
     EdgeNode* e;
     int i, k, gettop;
     int top = 0;/*用于栈指针下标*/
     int count = 0;/*用于统计输出顶点的个数*/
     int* stack;/*建栈存储入度为0的顶点*/
     stack = (int*)malloc(GL->numVertexes * sizeof(int));
     for (i = 0; i < GL->numVertexes; i++) {
       if (GL->adjList[i].in == 0) {
         stack[++top] = i;/*将入度为0的顶点入栈*/
       }
     }
     while (top != 0) {
       gettop = stack[top--];/*出栈*/
       cout << GL->adjList[gettop].data << "->";/*打印此顶点*/
       count++;/*统计输出顶点数*/
       for (e = GL->adjList[gettop].firstedge; e; e = e->next) {
         /*对此顶点弧表遍历*/
         k = e->adjvex;
         if (!(--GL->adjList[k].in)) {/*将k号顶点临界点的入度减1*/
           stack[++top] = k;/*若为0则入栈，便于下次循环输出*/
         }
       }
     }
     if (count < GL->numVertexes) {/*如果count小于顶点数，说明存在环*/
       return false;
     }
     else {
       return true;
}
```

![img](file:////tmp/wps-yzk/ksohtml/wpsZcZ4zh.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsR9nhu3.jpg)![img](file:////tmp/wps-yzk/ksohtml/wpsLgGxoP.jpg)![img](file:////tmp/wps-yzk/ksohtml/wps3aPRiB.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsVhlfdn.jpg) 

 

 

# 八、关键路径

Sunday, October 11, 2020

11:34 AM

如果我们要对一个流程图获得最短时间，就必须要分析它们的拓扑关系，并且找到当中最关键的流程，这个流程的时间就是最短时间。

**在一个表示工程的带权有向图中，用顶点表示时间，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网（Activity On Edge Nerwork）。AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。正常情况下，AOE网只有一个源点一个汇点。**

 

**AOE特点：在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始。只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生。**

![img](file:////tmp/wps-yzk/ksohtml/wps7duG78.jpg) 

 

**AOE和AOV的区别：**

**AOV网是顶点表示活动的网，它只描述活动之间的制约关系**

**AOE网是用边表示活动的网，边上的权值表示活动持续的时间，主要是建立在活动之间制约关系没有矛盾的基础上。**

 

![img](file:////tmp/wps-yzk/ksohtml/wpsLOFa2U.jpg) 

**路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动。**

**开始->发动机完成->部件集中到位>\组装完成就是关键路径，路径长为+0.5+2=5.5。**

 

**找到关键路径，是缩短工期的重要步骤。**

 

## 1.关键路径算法原理

我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。

 

定义以下几个参数：

事件的最早发生时间 etv （earlist time of vertex）：即顶点vk的最早发生时间。

事件的最晚发生时间 ltv  （latest time of vertex）：即顶点vk的最晚发生时间。

活动的最早开工时间 ete （earliest time of edge）：即弧ak的最早发生时间。

活动的最晚开工时间 lte  （latest time of edge）：即弧ak的最晚发生时间（不推迟工期）。

由1和2可以求得3和4，然后根据ete[k]是否与lte[k]相等来判断ak是否是关键活动。

 

## 2.关键路径算法

**将AOE网转换为邻接表结构，weight域用来存储弧的权值。**

![img](file:////tmp/wps-yzk/ksohtml/wpsx5sKWG.jpg) 

```c++
   1 /*关键路径*/
    2 int* etv, * ltv;/*事件最早发生时间和最迟发生时间数组*/
    3 int* stack2;/*用于存储拓扑序列*/
    4 int top2;/*用于stack2的指针*/
    5 /*拓扑排序，用于关键路径计算*/
    6 bool TopologicalSort(GraphAdjList GL) {
    7     EdgeNode* e;
    8     int i, k, gettop;
    9     int top = 0;/*用于栈指针下标*/
   10     int count = 0;/*用于统计输出顶点的个数*/
   11     int* stack;/*建栈将入度为0的顶点入栈*/
   12     stack = (int*)malloc((GL->numVertexes * sizeof(int));
   13     for (i = 0; i < GL->numVertexes; i++) {
   14         if (0 == GL->adjList[i].in)
   15             stack[++top] = i;
   16     }
   17     top2 = 0;
   18     etv = (int*)malloc(GL->numVertexes * sizeof(int));
   19     for (i = 0; i < GL->numVertexes; i++) {
   20         etv[i] = 0;
   21     }
   22     stack2 = (int*)malloc(GL->numVertexes * sizeof(int));
   23     while (top != 0) {
   24         gettop = stack[top--];
   25         count++;
   26         stack2[++top2] = gettop;/*将弹出的顶点序号压入拓扑序列的栈*/
   27 
   28         for (e = GL->adjList[gettop].firstedge; e; e = e->next) {
   29             k = e->adjvex;
   30             if (!(--GL->adjList[k].in)) {
   31                 stack[++top] = k;
   32             }
   33             if ((etv[gettop] + e->weight) > etv[k])/*求各顶点时间最早发生的时间值*/
   34                 etv[k] = etv[gettop] + e->weight;
   35         }
   36     }
   37     if (count < GL->numVertexes)
   38         return false;
   39     else
   40         return true;
           }
```

![img](file:////tmp/wps-yzk/ksohtml/wpsRQfARs.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsr2ruMe.jpg) 

```c++
1 /*求关键路径，GL为有向网，输出GL的各项关键活动*/
    2 void CriticalPath(GraphAdjList GL) {
    3     EdgeNode* e;
    4     int i, gettop, k, j;
    5     int ete, lte;    /*声明活动最早发生时间和 最迟发生时间变量*/
    6     TopologicalSort(GL);/*求拓扑序列，计算数组etv和stack2的值*/
    7     ltv = (int*)malloc(GL->numVertexes * sizeof(int));/*事件最晚发生时间*/
    8     for (i = 0; i < GL->numVertexes; i++) {
    9         ltv[i] = etv[GL->numVertexes - 1];/*初始化ltv*/
   10     }
   11     while (top2 != 0) {/*计算ltv*/
   12         gettop = stack2[top2--];/*将拓扑序列出栈，后进先出*/
   13         for (e = GL->adjList[gettop].firstedge; e; e = e->next) {
   14             /*求各顶点事件的最迟发生时间ltv值*/
   15             k = e->adjvex;
   16             if (ltv[k] - e->weight < ltv[gettop]) {/*求各顶点事件最晚发生时间ltv*/
   17                 ltv[gettop] = ltv[k] - e->weight;
   18             }
   19         }
   20     }
   21     for (j = 0; j < GL->numVertexes; j++) {
   22         for (e = GL->adjList[j].firstedge; e; e = e->next) {
   23             k = e->adjvex;
   24             ete = etv[j];
   25             lte = ltv[k] - e->weight;
   26             if (ete == lte) {
   27                 printf("<v%d,v%d> length: %d, ",
   28                     GL->adjList[j].data, GL->adjList[k].data, e->weight);
   29             }
   30         }
   31     } 
 32 }
```

  ![img](file:////tmp/wps-yzk/ksohtml/wpsVjpDH0.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps33GQCM.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsT6p6xy.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsD6Hptk.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsLd6Mo6.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsF77ekS.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsLf4KfE.jpg) 

**如果一个无环图上有多条关键路径，则必须同时提高在几条关键路径上的活动的速度，才能使工期缩短。**

 

 

 

 

# 九、总结

Tuesday, October 13, 2020

4:24 PM

通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。

![img](file:////tmp/wps-yzk/ksohtml/wpsD05lbq.jpg) 

图的遍历分为深度和广度两种，各有优缺点。

图的应用：最小生成树、最短路径和有向无环图的应用。

​    最小生成树算法：普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法。普里姆算法：走一步看一步的思维方式；克鲁斯卡尔：更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。

​    最短路径算法：迪杰斯特拉（Dijkstra）算法和弗洛伊德（Floyd）算法。迪杰斯特拉算法更强调单元顶点查找路径的方式，比较符合我们的正常思路，容易理解原理，但算法代码相对复杂。而弗洛伊德算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，原理理解有难度，但算法编写很简洁。

有向无环图时常应用于工程规划中，我们一方面关心工程能否顺利进行的问题，通过拓扑排序。另一方面关心整个工程完成所必须的最短时间问题，利用关键路径的算法，可以得到最短完成工程的工期以及关键的活动。