# 一、查找概论

Tuesday, October 13, 2020

4:50 PM

**查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。**

![img](file:////tmp/wps-yzk/ksohtml/wps0ni5nC.jpg)

**关键字（key）是数据元素中某个数据项的值，又称为键值。**

**若此关键之可以唯一地标识一个记录，则称此关键字为主关键字（Primary Key）。**

**对于那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字（Secondary Key）。**

**查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的元素（或记录）。**

 

**查找表按照操作方式来分有两大种：静态查找表和动态查找表。**

**静态查找表（Static Search Table）:只作查找操作的查找表。**

（1）查询某个“特定的”数据元素是否在查找表中。

（2）检索某个“特定的”数据元素和各种属性。

**动态查找表（Dynamic Search Table）：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。**

（1）查找时插入数据元素。

（2）查找时删除数据元素。

 

 

# 二、顺序表查找

Tuesday, October 13, 2020

5:06 PM

顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果知道最后一个 （或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

 

## 1.顺序表查找算法

  

```c++
1 #include<iostream>

  2 using namespace std;

  3 

  4 /*顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字*/

  5 int Sequential_Search(int* a,int n,int key) {

  6   int i;

  7   for (i = 0; i <= n; i++) {

  8     if (a[i] == key) {

  9       return i;

  10     }

  11   }

  12   return 0;

  13 }
```



## 2.顺序表查找优化

```c++
  1 /*有哨兵顺序查找*/

  2 int Sequential_Search2(int* a, int n, int key) {

  3   int i;

  4   a[0] = key;/*设置a[0]为关键字值，我们称之为“哨兵”*/

  5   i = n;/*循环从数组尾部开始*/

  6   while (a[i] != key) {

  7     i--;

  8   }

  9   return i;

  10 }


```

 

顺序查找优点：代码简单，对静态查找表的记录没有任何要求。缺点：当n很大时，查找效率低下

 

# 三、有序表查找

Tuesday, October 13, 2020

5:24 PM

## 1.折半查找

**折半查找（Binary Search）技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的的基本思想是：在有序表中，去中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。**

```c++
  1 /*折半查找*/

  2 int Binary_Search(int* a, int n, int key) {

  3   int low, high, mid;

  4   low = 1;    /*定义最低下标为记录首位*/

  5   high = n;    /*定义最高下标为记录末位*/

  6   while (low <= high) {

  7     mid = (low + high) / 2;/*折半*/

  8     if (key < a[mid]) {

  9       high = mid - 1;

  10     }

  11     else if (key > a[mid]) {

  12       low = mid + 1;

  13     }

  14     else {

  15       return mid;

  16     }

  17   }

  18   return 0;

  19 }

  20
```

折半算法的时间复杂度为O（logn）。

 

## 2.插值查找

**更改折半查找的mid=low+（high-low）*(key-a[low]）*（a[high]-a[low]);**

**插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式**

**插值查找（Intert）***

![img](file:////tmp/wps-yzk/ksohtml/wps8GmdoC.jpg)

 

## 3.斐波那契查找

**斐波那契查找（Fibonacci Search），利用了黄金分割原理实现。**

![img](file:////tmp/wps-yzk/ksohtml/wpsgwcebD.jpg)

 

```c++
 1 /*斐波那契查找*/

  2 int Fibonacci_Search(int *a,int n,int key){

  3    int low, high, mid, i, k;

  4    ABC abc;

  5    low = 1;  /*定义最低下标为记录首位*/

  6    high = n;  /*定义最高下标为记录末位*/

  7    k = 0;

  8    while(n>abc.F[k]-1){/*计算n位于斐波那契数列的位置*/

  9       k++;

  10    }

  11    for (i = n; i < abc.F[k] - 1; i++){/*将不满的数值补全*/

  12       a[i] = a[n];

  13    }

  14 

  15    while(low<=high){

  16       mid = low + abc.F[k - 1] - 1;  /*计算当前分隔的下标*/

  17    }

  18    if(key<a[mid]){   /*若查找记录小于当前分隔记录*/

  19       high = mid - 1;  /*最高下标调整到分隔下标减一位*/

  20       k = k - 1;    /*斐波那契数列下标减一位*/

  21    }

  22    else if(key>a[mid]){ /*若查找记录大于当前分隔记录*/

  23       low = mid + 1;  /*最低下标调整到分隔下标mid+1处*/

  24       k = k - 2;    /*斐波那契下标减两位*/

  25    }

  26    else{

  27       if(mid<=n)

  28          return mid; /*若相等则说明mid即为查找到的位置*/

  29       else

  30          return n;  /*若mid>n说明是补全数值，返回n*/

  31    }

  32 
```

![img](file:////tmp/wps-yzk/ksohtml/wpsS8aqWN.jpg)

 

![img](file:////tmp/wps-yzk/ksohtml/wpsMrn3Fz.jpg)

 

![img](file:////tmp/wps-yzk/ksohtml/wps0Dm4o4.jpg)

 

![img](file:////tmp/wps-yzk/ksohtml/wpsXCyZdg.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsslyXqI.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsXrqFEa.jpg) 

 

 

# 四、线性索引查找

Sunday, October 18, 2020

3:08 PM

**索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成。**

**所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。**

**三种常用线性索引：稠密索引、分块索引和倒排索引。**

 

## 1.稠密索引

**稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。**

![img](file:////tmp/wps-yzk/ksohtml/wpsQxCFSC.jpg) 

**对于稠密索引这个索引来说，索引项一定是按照关键码有序的排列，因为数据量过于庞大。**

 

**2.分块索引**

**块内无序，即每一块内的记录不要求有序，通常我们不要求块内有序，因为要付出大量时间和空间代价。**

**块内有序，只有块内有序，才有可能在查找时带来效率。**

 

我们定义的分块索引的索引项结构分为三个数据项：

最大关键码：存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中记录进行遍历。

存储了块中的记录个数，以便于循环时使用。

用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。

![img](file:////tmp/wps-yzk/ksohtml/wpsj6kO64.jpg) 

在分块索引中查找分两步进行：

1.在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。

2.根据块首指针找到相应的快，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找

 

![img](file:////tmp/wps-yzk/ksohtml/wps48g3kx.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsNCBnzZ.jpg) 

 

## 3.倒排索引

**搜索引擎查找单词表，返回文章的编号，整体速度非常快。单词表就是索引表。**

 

**索引项的通用结构是：**

**次关键码，例如搜索引擎中的英文单词。**

**记录号表，例如搜索引擎的文章编号。**

**其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（inverted index）。**

 

**倒排索引优点：查询速度快，查找时无需读取记录就可以得到结果。**

  **缺点：记录号不定长，若是对多篇文章所有单词建立倒排索引，每个单词都将对应相当多的文章编号，维护比较困难，插入和删除操作都需要作相应的处理。**

 

![img](file:////tmp/wps-yzk/ksohtml/wpsYgtQNr.jpg) 

 

 

 

# 五、二叉树排序

Sunday, October 18, 2020

4:10 PM

所谓优势只不过是比别人多深入思考一点而已。

![img](file:////tmp/wps-yzk/ksohtml/wpsd0Sq2T.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsOBt6gm.jpg) 

**二叉排序树（Binary Sort Tree）,又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树。**

**若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；**

**若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；**

**它的左右子树也分别为二叉排序树。**

 

**二叉排序树优点：提高了查找和插入删除关键字的速度。在一个有序数据集上的查找，速度总是要快于无序的数据集，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。**

 

## 1.二叉排序树查找操作

 

```c++
 1 /*二叉树的二叉链表结点结构定义*/

  2 typedef struct BiTNode{

  3    int data;

  4    struct BiTNode *lchild, *rchild;

  5 } BiTNode, *BiTree;

  6 

  7 /*递归查找二叉排序树T中是否存在key，指针f指向T的双亲，其初始调用值为NULL*/

  8 /*若查找成功，则指针p指向该数据元素结点，并返回TRUE*/

  9 /*否则指针p指向查找路径上访问的最后一个结点并返回FALSE*/

  10 bool SearchBST(BiTree T, int key, BiTree f, BiTree *p){

  11    if (!T){

  12       *p = f;

  13       return false;

  14    }

  15    else if (key==T->data){

  16       *p = T;

  17       return true;

  18    }

  19    else if (key<T->data){

  20       return SearchBST(T->lchild, key, T, p);/*在左子树继续查找*/

  21    }

  22    else{

  23       return SearchBST(T->rchild, key, T, p);/*在右子树继续查找*/

  24    }

}


```

 

![img](file:////tmp/wps-yzk/ksohtml/wpsXwjZvO.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsIUHZKg.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps9wM5ZI.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps4sghfb.jpg) 

 

## 2.二叉排序树插入操作

**所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已，来看代码。**

 

```c++
 1 /*当二叉排序树T中不存在关键字等于key的数据元素时，插入key并返回TRUE，否则返回FALSE*/

  2 bool InsertBST(BiTree *T,int key){

  3    BiTree p, s;

  4    if(!SearchBST(*T,key,NULL,&p))/*查找不成功*/{

  5       s = (BiTree)malloc(sizeof(BiTNode));

  6       s->data = key;

  7       s->lchild = s->rchild = NULL;

  8       if(!p)

  9          *T = s;   /*插入s为新的根结点*/

  10       else if(key<p->data)

  11          p->lchild = s; /*插入s为左孩子*/

  12       else

  13          p->rchild = s; /*插入s为右孩子*/

  14       return true;

  15    }

  16    else

  17       return false;/*树中已有关键字相同的结，不再插入*/

 }
```

有了插入代码，我们要实现二叉排序树的构建就非常容易了。

![img](file:////tmp/wps-yzk/ksohtml/wpsTaNDuD.jpg) 

 

 

## 3.二叉排序树删除操作

![img](file:////tmp/wps-yzk/ksohtml/wpsCHY8J5.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsT2iKZx.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpswpjsf0.jpg) 

**根据对删除结点三种情况的分析：**

**叶子结点；**

**仅有左或右子树的结点；**

**左右子树都有的结点。**

  

```c++
1 /*若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点，*/

  2 /*并返回TRUE;否则返回FALSE*/

  3 bool DeleteBST(BiTree *T,int key){

  4    if(!*T) /*不存在关键字等于key的数据元素*/

  5       return false;

  6    else {

  7       if(key==(*T)->data) /*找到关键字等于key的数据元素*/

  8          return Delete(T);

  9       else if (key<(*T)->data)

  10          return DeleteBST(&(*T)->lchild, key);

  11       else

  12          return DeleteBST(&(*T)->rchild, key);   

  13    }

  14 }

  15 

  16 /*从二叉排序树中删除结点p，并重接它的左或右子树*/

  17 bool Delete(BiTree *p){

  18    BiTree q, s;

  19    if((*p)->rchild==NULL){/*右子树空则只需要重接它的左子树*/

  20       q = *p;

  21       *p = (*p)->lchild;

  22       free(q);

  23    }

  24    else if((*p)->rchild==NULL){

  25       q = *p;

  26       *p = (*p)->rchild;

  27       free(q);

  28    }

  29    else{

  30       q = *p;

  31       s = (*p)->lchild;

  32       while(s->rchild){

  33          q = s;

  34          s = s->rchild;

  35       }

  36       (*p)->data = s->data;

  37       if(q!=*p){

  38          q->rchild = s->lchild;

  39       }

  40       else{

  41          q->lchild = s->lchild;

  42       }

  43       free(s);

  44    }

  45    return true;

}
```

![img](file:////tmp/wps-yzk/ksohtml/wpslKvsvs.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsosFyLU.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsv5ZK1m.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsoN93hP.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsnVwtyh.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsWIBYOJ.jpg) 

 

 

 

 

# 六、平衡二叉树（AVL树）

Tuesday, October 20, 2020

12:57 PM

**平衡二叉树（Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。是一种高度平衡的二叉树。**

**我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）。**

 

**满足平衡二叉树的前提条件是要满足二叉排序树。**

![img](file:////tmp/wps-yzk/ksohtml/wpsbspA5b.jpg) 

图一也不是平衡二叉树。

结点58的左右结点数相差2

 

![img](file:////tmp/wps-yzk/ksohtml/wpscVghmE.jpg) 

 

**距离插入结点最近的，且平衡因子的绝对值大于\*******\*1\*******\*的结点为根的子树，我们称为最小不平衡子树。**

![img](file:////tmp/wps-yzk/ksohtml/wpsJ8D3C6.jpg) 

 

## 1.平衡二叉树实现原理

![img](file:////tmp/wps-yzk/ksohtml/wpsogYVTy.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsheuVa1.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsAh38rt.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsr7i7JV.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsS0ij2n.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpslgTCkQ.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps6LG1Ci.jpg) 

## 2.平衡二叉树实现算法

```c++
/*二叉树的二叉链表结点结构定义*/
typedef struct BiTNode{				 /*结点结构*/
    int data;						 /*结点数据*/
    int bf;							 /*结点的平衡因子*/
    struct BiTNode *lchild, *rchild; /*左右孩子指针*/
}BiTNode, *BiTree;
/*对以P为根的二叉排序树作右旋处理，处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点*/
void R_Rotate(BiTree *p){
    BiTree L;
    L=(*p)->lchild;					/*L指向p的左子树根结点*/
    (*p)->lchild=L->rchild;			/*L的右子树挂接为P的左子树*/
    L->rchild=(*p);	
    *P=L;							/*P指向新的根结点*/
}
/*对以P为根的二叉排序树作左旋处理，处理之后P指向新的树根结点，即旋转处理之前的右子数的根结点0*/
void L_Rotate(BiTree *p){
    BiTree R;
    R=(*p)->rchild;					/*R指向p的右子数根结点*/
    (*p)->rchild=R->lchild;			/*R的左子树挂接为p的右子树*/
    R->lchild=(*p);					
    *p=R;							/*p指向新的根结点*/
}
```

​		R_Rotate当传入一个二叉排序树P，将它的左孩子结点定义为L，将L的右子数变成P的左子树，再将P改成L的右子数，最后将L替换P成为根结点。这样就完成了一次右旋操作。

​		L_Rotate与右旋代码对称。

现在我们来看左平横旋转处理的函数代码。

```c++
#define LH +1		/*左高*/
#define EH 0		/*等高*/
#define RH -1		/*有高*/
/*对以指针T所指结点为根结点为根的二叉树作平衡的旋转处理*/
/*本算法结束时，指针T指向新的根结点*/
void LeftBalance(BiTree *T){
    BiTree L,Lr;
    L=(*T)->lchild;		/*L指向T的左子树根结点*/
    switch(L->bf){/*检查T的左子树的平衡度，并作相应平衡处理*/
        case LH:/*新结点插入在T的左孩子的左子树上，要做单右旋处理*/
            (*T)->bf=L->bf=EH;
            R_Rotate(T);
            break;
        case RH:	/*新结点插入在T的左孩子的左子树上，要做双旋处理*/
            Lr=L->rchild;	/*Lr指向T的左孩子的右子树根*/
            switch(Lr->bf){
                case LH:(*T)->bf=RH;
                    L->bf=RH;
                    break;
                case EH:(*T)->bf=L->bf=EH;
                    break;
                case RH:(*T)->bf=EH;
                    L->bf=LH;
                    break;
            }
            Lr->bf=EH;
            L_Rotate(&(*T)->lchild);		/*对T的左子树作左旋平衡处理*/
            R_Rotate(T);					/*对T作右旋平衡处理*/
    }
}
```

首先，我们定义了三个常数变量，分别代表1、0、-1。

1. 函数被调用，传入一个需调整平衡性的子数T。由于LeftBalance函数被调用时，其实是已经确认当前子数是不平衡状态，且左子树的高度大于右子树的高度。换句话说，此时T的根结点应该是平衡印子BF的值大一1的数。
2. 第4行，我们将T的左孩子赋值给L。
3. 第5~27行是分支判断。                                                                    
4. 当L的平衡因子为LH，即为1时，表明它与根结点的BF值符号相同，因此，第8行，将它们的BF值都改为0，并且第九行，进行右旋操作。
5. 当L的平衡因子为RH，即为-1时，表明它与根结点的BF值符号相反，此时需要做双旋处理。第13~22行，针对L的有孩子Lr的BF作判断，修改根结点T和L的BF值。第24行将当前Lr的BF改为0。
6. 第25行，对根结点的左子树进行左旋。
7. 第26行，对根结点进行右旋，完成平衡操作。

主要函数：

```c++
/*若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个数据元素为e的新结点*/
/*并返回1，否则返回0。若因插入而使二叉排序树数去平衡，则作平衡旋转处理，布尔变量*/
/*taller反应T长高与否*/
Status InsertAVL(BiTree *T,int e,Status *taller){
    if(!*T){
        /*插入新结点，数长高，置taller为TRUE*/
        *T=(BiTree)malloc(sizeof(BiTNode));
        (*T)->data=e;
        (*T)->lchild=(*T)->rchild=NULL;
        (*T)->bf=EH;
        *taller=TRUE;
    }
    else{
        if(e==(*T)->data){
            /*树中已存在和e有相同关键字的结点则不再插入*/
            *taller=FALSE;
            return FALSE;
        }
        if(e<(*T)->data){
            /*应继续在T的左子树中进行搜索*/
            if(!InsertAVL(&(*T)->lchild,e,taller))	/*未插入*/
                return FALSE;
            if(taller){
                /*已插入到T的左子树中且左子树“长高”*/
                switch((*T)->bf){
                        /*检查T的平衡度*/
                    case LH:/*原本左子树比右子数高，需要作左平衡处理*/
                        LeftBalance(T);
                        *taller=FALSE;
                        break;
                    case EH:/*原本左右子数等高，先因左子树增高而树增高*/
                        (*T)->bf=LH;
                        *taller=TRUE;
                        break;
                    case RH:/*原本右子数比左子树高，现在右子数等高*/
                        (*T)->bf=EH;
                        *taller=FALSE;
                        break;
                }
            }
        }
        else{
            /*应继续在T的右子数中进行搜索*/
            if(!InsertAVL(&(*T)->rchild,e,taller))/*未插入*/
                return FALSE;
            if(*taller){
                switch((*T)->bf){
                    case LH:/*原本左子树比右子数高，现在左右子数等高*/
                        (*T)->bf=EH;
                        *taller=FALSE;
                        break;
                    case EH:/*原本左右子数等高，现因右子数增高而树增高*/
                        (*T)->bf=RH;
                        *taller=TRUE;
                        break;
                    case RH:/*原本右子树比左子树高。需要作右平衡处理*/
                        RightBalance(T);
                        *taller=FALSE;
                        break;
                }
            }
        }
    }
    return true;
}
```

