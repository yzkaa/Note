# 一、树的定义

2020年8月11日

19:52

**树（Tree）是n（n>=0）个结点的有限集。n=0时称为空树。在任意一颗非空树中：**

**（1）有且仅有一个特定的称为根（Root）的结点；**

**（2）当n>1时，其余节点可分为m（m>0）个互不相交的有限集T1,T2,……Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。**

![img](file:////tmp/wps-yzk/ksohtml/wpsU5CuX4.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wps9aMr4k.jpg) 

**（1）n>0时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。**

**（2）m>0时，子树的个数没有限制，但它们一定是互不相交的。**

 

## 1.结点分类

**结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点；度不为零的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。**

![img](file:////tmp/wps-yzk/ksohtml/wpsI7EtbB.jpg) 

## 2.结点间关系

**结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。以某结点为根的子树中的任一结点都成为该结点的子孙。**

![img](file:////tmp/wps-yzk/ksohtml/wpsNOOyiR.jpg) 

## 3.树的其他相关概念

**结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度**

![img](file:////tmp/wps-yzk/ksohtml/wps85CGp7.jpg) 

**如果将树中结点的各子树看成从左至右是有顺序的，不能互换的，则称该树为有序树，否则称为无序树。**

**森林（Forest）是m（m>=0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。**

 

**对比线性表与树的结构，有很大不同**

![img](file:////tmp/wps-yzk/ksohtml/wpsZMlRwn.jpg) 

  

# 二、树的抽象数据类型

2020年8月11日

20:13

![img](file:////tmp/wps-yzk/ksohtml/wps5XUkLT.jpg) 

 

 

# 三、树的存储结构

2020年8月11日

20:26

 

## 1.双亲表示法

**在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。**

```c++
/*树的双亲表示法结点结构定义*/
constexpr auto MAX_TREE_SIZE =  100;
 
typedef int TElemType;
typedef struct PTNode {
        TElemType data;/*结点数据*/
        int parent;/*双亲位置*/
}PTNode;
 
typedef struct {/*树结构*/
        PTNode nodes[MAX_TREE_SIZE];/*结点数组*/
        int r, n;   /*根的位置和结点数*/
}PTree;
```



由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，所有的结点都存有它双亲的位置。

 

![img](file:////tmp/wps-yzk/ksohtml/wpseWNMS9.jpg) 

根据节点的parent指针很容易找到它的双亲结点，时间复杂度为O{1}。parent为-1时，表示找到了树结点的根。如果要知道结点的孩子需要遍历整个树结构。

**改进：增加一个结点最左边孩子的域，长子域，如果没有孩子的结点，长子域就设置为-1**

![img](file:////tmp/wps-yzk/ksohtml/wpsf1dh0p.jpg) 

**改进：增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标，如果右兄弟不在，则赋值为-1。**

![img](file:////tmp/wps-yzk/ksohtml/wps2zON7F.jpg) 

 

**如果结点的孩子很多，我们又关注结点的双亲、又关注孩子、还关注兄弟，而且对时间遍历要求比较高，那么我们还可以扩展结构，如双亲域、长子域、再有右兄弟域。**

**存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。**

 

## 2.孩子表示法

**每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法。**

![img](file:////tmp/wps-yzk/ksohtml/wpsrD9mfW.jpg) 

**这种方法对玉树中各结点的度相差很大时，显然是很浪费空间的，不过对于各结点度相差很小的树，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。**

![img](file:////tmp/wps-yzk/ksohtml/wpsw7j0mc.jpg) 

**第二种方法克服了浪费空间的缺点，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，运算上就会带来时间上的损耗。**

**孩子表示法：把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。**

![img](file:////tmp/wps-yzk/ksohtml/wps1ZaHus.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpswKHqCI.jpg) 

  

```c++
/*树的孩子表示法结构定义*/
typedef struct CTNode {/*孩子结点*/
        int child;
        struct CTNode* next;
}*ChildPtr;
 
typedef struct {/*表头结构*/
        TElemType data;
        ChildPtr firstchild;
}CTBox;
 
typedef struct {/*树结构*/
        CTBox nodes[MAX_TREE_SIZE];/*结点数组*/
        int r,n;/*根的位置和结点数*/
}CTree;
```



优点：对于要查找某个结点的某个孩子，或某个结点的兄弟，只需要查找单链表即可。对于整棵树遍历也很方便，对头结点的数值循环即可。

问题：要想知道某个孩子的双亲，需要整棵树遍历

 

## 3.孩子兄弟表示法

**任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的，因此，我们设置两个指针，分别指向该点的第一个孩子和此结点的右兄弟。**

 

![img](file:////tmp/wps-yzk/ksohtml/wpsaLsQ7K.jpg) 

 

```c++
/*树的孩子兄弟表示法结构定义*/
typedef struct CSNode {
        TElemType data;
        struct CSNode* firstchild, * rightsib;
}CSNode,*CSTree;
```

 

![img](file:////tmp/wps-yzk/ksohtml/wpszQOPf1.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsMbJRnh.jpg) 

可以增加一个parent指针域来解决快速查找双亲问题。

 

 

# 四、二叉树定义

2020年8月12日

10:16

**二叉树（Binary Tree）是n（n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。**

![img](file:////tmp/wps-yzk/ksohtml/wpsJDEWvx.jpg) 

## 1.二叉树特点

**每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。**

**左子树和右子树是有顺序的，次序不能任意颠倒。**

**即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。**

![img](file:////tmp/wps-yzk/ksohtml/wpsopH3DN.jpg) 

 

二叉树具有五种基本形态：

* 空二叉树.

* 只有一个根结点

* 根结点只有左子树

* 根结点只有右子树

* 根结点既有左子树又有右子树

 

 

若有三个结点的二叉树，结构如下

![img](file:////tmp/wps-yzk/ksohtml/wpsBpmdM3.jpg) 

## 2.特殊二叉树

**斜树：**

**所有的结点都只有左子树的二叉树叫左斜树。右斜树同理，两者统称斜树。**

**满二叉树：**

**在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。**

![img](file:////tmp/wps-yzk/ksohtml/wps0qcpUj.jpg) 

**满二叉树的特点：**

* **叶子只能出现在最下一层。出现在其它层就不可能达成平衡。**

* **非叶子结点的度一定是2。**

* **在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。**

**完全二叉树：**

**对一棵具有n个结点的二叉树按层编号，如果编号为i（1<=i<=n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树为完全二叉树。**

![img](file:////tmp/wps-yzk/ksohtml/wpsHXyD2z.jpg) 

**完全二叉树不一定满，但是编号一定是连续的。**

**完全二叉树的特点：**

* **叶子结点只能出现在最下两层。**

* **最下成的叶子一定集中在左部连续位置。**

* **倒数二层，若有叶子结点，一定都在右部连续位置。**

* **如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。**

* **同样结点数的二叉树，完全二叉树的深度最小。**

 

 

 

# 五、二叉树的性质

2020年8月12日

10:42

## 1,二叉树性质1

**在二叉树的第i层上至多有2^(i-1)个结点（i>=1）。**

## 2.二叉树性质2

 **深度为k的二叉树至多有（2^k）-1个结点（k>=1）。**

## 3.二叉树性质3

**对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。**

![img](file:////tmp/wps-yzk/ksohtml/wpsM0FVaQ.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsfD1fj6.jpg) 

## 4.二叉树性质4

![img](file:////tmp/wps-yzk/ksohtml/wpsccKCrm.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpsBwD1zC.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsm9tuIS.jpg) 

## 5.二叉树性质5

![img](file:////tmp/wps-yzk/ksohtml/wpsrGMZQ8.jpg) 

**如果i=1，则结点i是二叉树的根，无双亲；如果是i>1，其双亲是结点[i/2]。**

**如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。**

**如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。**

![img](file:////tmp/wps-yzk/ksohtml/wpsES7xZo.jpg) 

  

 

# 六、二叉树的存储结构

2020年8月12日

11:35

## 1.二叉树顺序存储结构

![img](file:////tmp/wps-yzk/ksohtml/wpsYR4uPX.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsFdQgYd.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpswdY46t.jpg) 

## 2.二叉链表

**二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，我们称这样的链表叫做二叉链表。**

 

```c++
/*二叉树的二叉链表结点结构定义*/
typedef struct BiTNode {/*结点结构*/
        TElemType data;
        struct BiTNode* lchild, * rchild;
}BiTNode，BiTree*;
```

 

![img](file:////tmp/wps-yzk/ksohtml/wpstgFXfK.jpg) 

 

 

# 七、遍历二叉树

2020年8月13日

10:32

## 1.二叉树遍历原理

**二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次**

关键词：访问和次序。

## 2.二叉树遍历方法

* 前序遍历

**若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树**

![img](file:////tmp/wps-yzk/ksohtml/wpsIkuTo0.jpg) 

* **中序遍历**

**从根结点开始（并不是先访问根结点），中序遍历根结点的左子树，然后\**** ***\*访问根结点，最后中序遍历右子树**

![img](file:////tmp/wps-yzk/ksohtml/wpstfLRxg.jpg) 

* **后序遍历**

**从左到右先叶子后结点的方式便利访问左右子树，最后是访问根结点。**

![img](file:////tmp/wps-yzk/ksohtml/wpsu1kSGw.jpg) 

* **层序遍历**

**从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。**

![img](file:////tmp/wps-yzk/ksohtml/wpsz6uVPM.jpg) 

**在程序中，本质上把树中的结点变成某种意义的线性序列。**

 

## 3.前序遍历算法

 

```c++
/*前序遍历算法*/
void PreOrderTraverse(BiTNode* T) {
        if (T == NULL) {
                return;
        }
        cout << T->data << endl;/*显示结点数据，可以更改为其他对结点操作*/
        PreOrderTraverse(T->lchild);/*再先序遍历左子树 */
        PreOrderTraverse(T->rchild);/*最后先序遍历右子树*/
}
```

## 4.中序遍历算法

```c++
/*中序遍历算法*/
     void InOrderTraverse(BiTNode* T) {
         if (T == NULL) {
             return;
         }
         InOrderTraverse(T->lchild);/*中序遍历左子树 */
         cout << T->data << endl;/*显示结点数据，可以更改为其他对结点操作*/
         InOrderTraverse(T->rchild);/*最后中序遍历右子树*/
     }
```

##  5.后序遍历算法

```c++
 /*后序遍历算法*/
     void PostOrderTraverse(BiTNode* T) {
         if (T == NULL) {
             return;
         }
         PostOrderTraverse(T->lchild);/*先后序遍历左子树 */
         PostOrderTraverse(T->rchild);/*再后序遍历右子树*/
         cout << T->data << endl;/*显示结点数据，可以更改为其他对结点操作*/
     }
```

## 6.推导遍历结果

## ![img](file:////tmp/wps-yzk/ksohtml/wps2G18Y2.jpg) 

![img](file:////tmp/wps-yzk/ksohtml/wpshYZo8i.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsAm8Ihz.jpg) 

**二叉树遍历的性质：**

**已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。**

**已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。**

**已知前序和后序遍历，无法确定一棵二叉树。**

 

 

# 八、二叉树的建立

2020年8月14日

11:55

为了能让每个结点确认是否有左右孩子，我们对普通二叉树进行扩展，将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，我们称这种处理后的二叉树为原二叉树的扩展二叉树

![img](file:////tmp/wps-yzk/ksohtml/wpsL0abrP.jpg) 

 

```c++
 /*按前序输入二叉树中结点的值（一个字符）*/
     /*#表示空树，构造二叉链表表示二叉树T*/
     void CreatBiTree(BiTree* T) {
         TElemType ch;
         cin >> ch;
         if (ch == '#') {
             *T = NULL;
         }
         else {
            *T = (BiTree)malloc(sizeof(BiTNode));
            if (!*T) {
                exit(OVERFLOW);
            }
            (*T)->data = ch;/*生成根结点*/
            CreatBiTree(&(*T)->lchild);/*构造左子树*/
            CreatBiTree(&(*T)->rchild);/*构造右子树*/
        }
}
```

 

# 九、线索二叉树

2020年8月14日

15:50

## 1.线索二叉树原理

![img](file:////tmp/wps-yzk/ksohtml/wpsqo5JA5.jpg) 

**对于一个有n个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是2n个指针域。而n个结点的二叉树一共有n-1条分支线数，也就是说，其实是存在2n-（n-1）=n+1个空指针域。**

**我们把这种指向前驱和后继的指针称为线索。加上线索的二叉链表称为线索链表，相应的二叉树就成为线索二叉树（Threaded Binary Tree）。**

![img](file:////tmp/wps-yzk/ksohtml/wpsfYOlKl.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpssrL0TB.jpg) 

**对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化。**

![img](file:////tmp/wps-yzk/ksohtml/wpsjeYI3R.jpg) 

怎么知道指针指向的是孩子还是前驱或后驱？

![img](file:////tmp/wps-yzk/ksohtml/wpssIFud8.jpg) 

其中：

ltag为0时指向该结点的左孩子，为1时指向该结点的前驱。

rtag为0时指向该结点的右孩子，为1时指向该结点的后继。

![img](file:////tmp/wps-yzk/ksohtml/wpsffZino.jpg) 

## 2.线索二叉树的实现

```c++
/*二叉树的二叉线索存储结构定义*/
typedef enum { Link, Thread } PointerTag;/*Link==0 表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索*/
typedef struct BiThrNode {/*二叉线索存储结点结构*/
        TElemType data;/*结点数据*/
        struct BiThrNode* lchild, * rchild;/*左右孩子指针*/
        PointerTag LTag;
        PointerTag RTag;/*左右标志*/
}BiThrNode,*BiThrTree;
```

**线索化的过程就是在遍历的过程中修改空指针的过程。**

```c++
BiThrTree pre;/*全局变量，始终指向刚刚访问过的结点*/
/*中序遍历进行中序线索化*/
void InThreading(BiThrTree p) {
        if (p) {
                InThreading(p->lchild);/*递归左子树线索化*/
                if (!p->lchild) {
                        p->LTag = Thread;/*前驱线索*/
                        p->lchild = pre;/*左孩子指针指向前驱*/
                }
                if (!pre->rchild) {
                        pre->RTag = Thread;/*后继线索*/
                        pre->rchild = p;/*前驱右孩子指针指向后继（当前结点p）*/
                }
                pre = p;/*保持pre指向p的前驱*/
                InThreading(p->rchild);/*递归右子树线索化*/
        }
}
```

**除了加粗代码以外，和二叉树中序遍历的递归代码几乎完全一样。**

**有了线索二叉树后，遍历时相当于操作一个双向链表结构。**

![img](file:////tmp/wps-yzk/ksohtml/wpsAslkxE.jpg) 

```c++
       BiThrTree p;
        p = T->lchild;/*p指向根结点*/
        while (p != T) {/*空树或遍历结束时，p==T*/
                while (p->LTag == Link)/*当LTag==0时循环到中序序列的第一个结点*/
                        p = p->lchild;
                cout << p->data << endl;
                while (p->RTag == Thread && p->rchild != T) {
                        p = p->rchild;
                        cout << p->data;
                }
                p = p->rchild;
        }
        return 1;
}
```

 

![img](file:////tmp/wps-yzk/ksohtml/wpsnjSyHU.jpg) 

**如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。**

 

 

# 十、树、森林与二叉树的转换

2020年8月14日

17:04

## 1.树转换为二叉树

**加线。在所有兄弟结点之间加一条线。**

**去线。对书中每个结点，只保留与它第一个孩子结点的连线，删除它与其他孩子结点之间的连线。**

**层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的是孩子结点的右孩子。**

![img](file:////tmp/wps-yzk/ksohtml/wpsUcCTRa.jpg) 

## 2.森林转换为二叉树

森林是由若干棵树组成的，所以可以完全理解为，森林中的每一棵树都是兄弟，可以按兄弟的处理办法 来操作：

**把每棵树转换为二叉树。**

**第一棵二叉树不动，从第二棵二叉树开始，一次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。**

![img](file:////tmp/wps-yzk/ksohtml/wpsBT2g2q.jpg) 

## 3.二叉树转换为树

**加线。若某结点的左孩子结点存在，则将这个左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子的结点用线连接起来。**

**去线。删除原二叉树中所有结点与其右孩子结点的连线。**

**层次调整。使之结构层次分明。**

![img](file:////tmp/wps-yzk/ksohtml/wpsuUHHcH.jpg) 

## 4.二叉树转换为森林

**从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除，重复上述操作，知道所有右孩子连线都删除为止，得到分离的二叉树。**

**再将每棵分离后的二叉树转换为树即可。**

![img](file:////tmp/wps-yzk/ksohtml/wpsHKIcnX.jpg) 

## 5.树与森林的遍历

树的遍历分为两种方式。

一种是先遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。

另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。

森林的遍历也分为两种方式：

**前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。**

**后序遍历：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。**

 

 

# 十一、赫夫曼树及其应用

2020年8月14日

17:51

## 1.赫夫曼树定义与原理

**从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。**

**树的路径长度就是从树根到每一结点的路径长度之和。**

![img](file:////tmp/wps-yzk/ksohtml/wpsIkyLxd.jpg) 

**如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度Li与结点上权Wi的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。**

**带权路径长度WPL最小的二叉树称作赫夫曼树。**

**二叉树a的WPL=315，二叉树b的WPL=220。**

**相当于10000个数据，用二叉树a要做31500次比较，用二叉树b要做220000次比较。**

 

**赫夫曼树构建方法：**

**先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列。**

**取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是A为N1的左孩子，E为N1的右孩子。**

**将N1替换A与E，插入有序序列中，保持从小到大排列。**

**重复步骤b，将N1与B作为一个新结点N2的两个子结点。**

![img](file:////tmp/wps-yzk/ksohtml/wpsR1toIt.jpg) 

**将N2替换N1与B，插入有序序列中，保持从小到大排列。**

**重复步骤b。将N2与D作为一个新结点N3的两个子结点。**

**将N3替换N2与D，插入有序序列中，保持从小到大排列。**

**重复步骤b。将C与N3作为一个新节点T的两个子结点，完成赫夫曼树的构造。**

![img](file:////tmp/wps-yzk/ksohtml/wpskRK3SJ.jpg) 

 

此时右图带权路径长度WPL=205，是最优的赫夫曼树。

虽然是赫夫曼树，但由于每次判断都要两次比较，所以总体性能上不如该树。这不是我们要考虑的重点。

![img](file:////tmp/wps-yzk/ksohtml/wps5WRL3Z.jpg) 

**通过刚才的步骤，我们可以得出构造赫夫曼树的赫夫曼算法描述：**

**根据给定的n个权值（w1，w2，……，wn）构成n棵二叉树的集合F=（T1,T2,……,Tn），其中每棵二叉树T1中只有一个带权为w1的根结点，其左右子树均为空。**

**在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。**

**在F中删除这两棵树，同时将新得到的二叉树加入F中。**

**重复2和3步骤，直到F只含一颗树位置。这棵树便是赫夫曼树。**

 

## 2.赫夫曼编码

**赫夫曼研究这种最优树的目的是为了解决当年远距离通信（主要是电报）的数据传输的最优化问题。**

![img](file:////tmp/wps-yzk/ksohtml/wps0Kcyeg.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsfx2npw.jpg) 

**若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码。**

![img](file:////tmp/wps-yzk/ksohtml/wps488gAM.jpg) 

 

 

 

# 十二、总结

2020年8月14日

22:15

 

![img](file:////tmp/wps-yzk/ksohtml/wpsbPfiL2.jpg) 

 

![img](file:////tmp/wps-yzk/ksohtml/wpsMJsrWi.jpg) 