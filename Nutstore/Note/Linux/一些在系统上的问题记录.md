# 一、    Linux shell中运行命令后加上字符“&”的作用

& 放在启动参数后面表示设置此进程为后台进程

默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个'&'实现这个目的。

**前后台间切换**

可以通过bg （background）和fg（foreground）命令将其在前后台间状态切换。

**守护进程**

如果一个进程永远都是以后台方式启动，并且不能受到Shell退出影响而退出，一个正统的做法是将其创建为守护进程。守护进程值得是系统长期运行的后台进 程，类似Windows服务。守护进程信息通过ps –a无法查看到，需要用到–x参数，当使用这条命令的时候，往往还附上-j参数以查看作业控制信息，其中TPGID一栏为-1就是守护进程。

```shell
$ ps -xj
   PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND
   953 1190 1190 1190 ? -1 Ss 1000 0:00 /bin/sh /usr/bin/startkde
   1   1490 1482 1482 ? -1 Sl 1000 0:00 /usr/bin/VBoxClient –seamless
   1   1491 1477 1477 ? -1 Sl 1000 0:00 /usr/bin/VBoxClient –display
```

创建守护进程最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。成功调用该函数的结果是：

- 创建一个新的Session，当前进程成为Session Leader，当前进程的id就是Session的id
- 创建一个新的进程组，当前进程成为进程组的Leader，当前进程的id就是进程组的id
- 如果当前进程原本有一个控制终端，则它失去这个控制终端，成为一个没有控制终端的进程。

# 二、ubuntu20.04下安装向日葵X

安装时出现依赖不满足的情况，libwebkitgtk-3.0-0无法被安装

换源之后依然无法解决问题。

原因：该文件已经更新至新版本，但是在向日葵的deb包中还是引用了旧版本的文件，所以换源也无法找到。

解决方案：

展开向日葵的deb包

```shell
dpkg-deb -X SunloginClient-10.1.1.38139_amd64.deb sun
```

展开依赖文件

```shell
dpkg-deb -e SunloginClient-10.1.1.38139_amd64.deb sun/DEBIAN
```

修改control文件

```shell
vim sun/DEBIAN/control
```

修改文件内容，将libwebkitgtk 3.0-0修改为libwebkit2gtk-4.0-37

重新进行打包

```shell
dpkg-deb -b sun
```





# 三、ubuntu20.04下制作系统启动盘

首先准备好系统文件，然后打开终端，使用dd命令

dd：用指定的大小拷贝一个文件，并在拷贝的同时进行指定的转换。

**参数注释：**

1. if=文件名：输入文件名，缺省为标准输入。即指定源文件。< if=input file >
2. of=文件名：输出文件名，缺省为标准输出。即指定目的文件。< of=output file >
3. ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。
   obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。
   bs=bytes：同时设置读入/输出的块大小为bytes个字节。
4. cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。
5. skip=blocks：从输入文件开头跳过blocks个块后再开始复制。
6. seek=blocks：从输出文件开头跳过blocks个块后再开始复制。
   注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。
7. count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。
8. conv=conversion：用指定的参数转换文件。

- - ascii：转换ebcdic为ascii
  - ebcdic：转换ascii为ebcdic
  - ibm：转换ascii为alternate ebcdic
  - block：把每一行转换为长度为cbs，不足部分用空格填充
  - unblock：使每一行的长度都为cbs，不足部分用空格填充
  - lcase：把大写字符转换为小写字符
  - ucase：把小写字符转换为大写字符
  - swab：交换输入的每对字节
  - noerror：出错时不停止
  - notrunc：不截短输出文件
  - sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。

```shell
sudo dd if=xxx.iso of= xxx
```

其中，if=后面为镜像文件的路径，of=后面是目标磁盘，制作启动盘则为u盘，注意这里的目标磁盘不是磁盘路径，是/dev/sda这样的路径

```shell
#查看磁盘位置
sudo fdisk -l
```

dd运行过程中终端不会有任何反馈，但是可以通过磁盘读写情况判断是否在运行。



# 四、ubuntu20.04下安装deepin-QQ/weChart

```shell
wget -O- https://deepin-wine.i-m.dev/setup.sh | sh
sudo apt-get install deepin.com.wechat
sudo apt-get install deepin.com.qq.im
```



# 五、Git的使用

Git官网：https://git-scm.com/

## 1. Git概念 

### 1.1. Git库中由三部分组成 

​    Git 仓库就是那个.git 目录，其中存放的是我们所提交的文档索引内容，Git 可基于文档索引内容对其所管理的文档进行内容追踪，从而实现文档的版本控制。.git目录位于工作目录内。 
1） 工作目录：用户本地的目录； 
2） Index（索引）：将工作目录下所有文件（包含子目录）生成快照，存放到一个临时的存储区域，Git 称该区域为索引。 

3） 仓库：将索引通过commit命令提交至仓库中，每一次提交都意味着版本在进行一次更新。

### 1.2. 使用Git时的初始化事项 

#### 1.2.1. Git初始化配置 

1） 配置使用git仓库的人员姓名 
    git config --global user.name "Your Name Comes Here" 
2） 配置使用git仓库的人员email 
    git config --global user.email you@yourdomain.example.com 

#### 1.2.2. Git文档忽略机制 

工作目录中有一些文件是不希望接受Git 管理的，譬如程序编译时生成的中间文件等等。Git 提供了文档忽略机制，可以将工作目录中不希望接受Git 管理的文档信息写到同一目录下的.gitignore 文件中。 
例如：工作目录下有个zh目录，如果不想把它加入到Git管理中，则执行： 
    echo “zh” &gt; .gitignore 
    git add . 
有关gitignore 文件的诸多细节知识可阅读其使用手册：man gitignore 

#### 1.3. Git与Repo的比较 

​    Git操作一般对应一个仓库，而Repo操作一般对应一个项目，即一个项目会由若干仓库组成。 
例如，在操作整个Recket项目时使用Repo，而操作其中的某个仓库时使用Git。在包含隐藏目录.git的目录下执行git操作。

## 2. [Git](http://lib.csdn.net/base/git) help 

​    Git help 获取git基本命令 
（如果要知道某个特定命令的使用方法，例如：使用Git help clone，来获取git clone的使用方法）

## 3. Git本地操作基本命令 

### 3.1. Git init 

或者使用git init-db。 
创建一个空的Git库。在当前目录中产生一个.git 的子目录。以后，所有的文件变化信息都会保存到这个目录下，而不像CVS那样，会在每个目录和子目录下都创建一个CVS目录。 
在.git目录下有一个config文件，可以修改其中的配置信息。 

### 3.2. Git add 

将当前工作目录中更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步。 
可以递归添加，即如果后面跟的是一个目录作为参数，则会递归添加整个目录中的所有子目录和文件。例如： 
    git add dir1 （ 添加dir1这个目录，目录下的所有文件都被加入 ） 
    Git add f1 f2 （ 添加f1，f2文件） 
    git add .   ( 添加当前目录下的所有文件和子目录 ) 

### 3.3. Git rm 

从当前的工作目录中和索引中删除文件。 
可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件。例如： 
    git rm –r * （进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录） 
    git rm f1  (删除文件f1，包含本地目录和index中的此文件记录) 
    git rm --ached f1 (删除文件f1，不会删除本地目录文件，只删除index中的文件记录；将已经git add的文件remove到cache中,这样commit的时候不会提交这个文件, 适用于一下子添加了很多文件, 却又想排除其中个别几个文件的情况.) 

### 3.4. Git commit 

提交当前工作目录的修改内容。 
直接调用git commit命令，会提示填写注释。通过如下方式在命令行就填写提交注释：git commit -m "Initial commit of gittutor reposistory"。 注意，和CVS不同，git的提交注释必须不能为空，否则就会提交失败。 
    git commit还有一个 -a的参数，可以将那些没有通过git add标识的变化一并强行提交，但是不建议使用这种方式。 
每一次提交，git就会为全局代码建立一个唯一的commit标识代码，用户可以通过git reset命令恢复到任意一次提交时的代码。 
    git commit –-amend –m “message” （在一个commit id上不断修改提交的内容） 

### 3.5. Git status 

查看版本库的状态。可以得知哪些文件发生了变化，哪些文件还没有添加到git库中等等。 建议每次commit前都要通过该命令确认库状态。 
最常见的误操作是， 修改了一个文件， 没有调用git add通知git库该文件已经发生了变化就直接调用commit操作， 从而导致该文件并没有真正的提交。这时如果开发者以为已经提交了该文件，就继续修改甚至删除这个文件，那么修改的内容就没有通过版本管理起来。如果每次在 提交前，使用git status查看一下，就可以发现这种错误。因此，如果调用了git status命令，一定要格外注意那些提示为 “Changed but not updated:”的文件。 这些文件都是与上次commit相比发生了变化，但是却没有通过git add标识的文件。 

### 3.6. Git log 

查看历史日志，包含每次的版本变化。每次版本变化对应一个commit id。 
    Git log -1 
    -1的意思是只显示一个commit，如果想显示5个，就-5。不指定的话，git log会从该commit一直往后显示。 
    Git log --stat –summary （显示每次版本的详细变化） 
在项目日志信息中，每条日志的首行（就是那一串字符）为版本更新提交所进行的命名，我们可以将该命名理解为项目版本号。项目版本号应该是唯一的，默认由 Git 自动生成，用以标示项目的某一次更新。如果我们将项目版本号用作git-show 命令的参数，即可查看该次项目版本的更新细节。例如： 
1) Git log

2）Git show
实际上，上述命令并非是真正的进行版本号自定义，只是制造了一个tag对象而已，这在进行项目版本对外发布时比较有用。 

### 3.7. Git merge 

把服务器上下载下来的代码和本地代码合并。或者进行分支合并。 
例如：当前在master分支上，若想将分支dev上的合并到master上，则git merge dev 
注意：git merge nov/eclair_eocket （是将服务器git库的eclair_eocket分支合并到本地分支上） 
    git rebase nov/eclair_eocket （是将服务器git库的eclair_eocket分支映射到本地的一个临时分支上，然后将本地分支上的变化合并到这个临时分支，然后再用这个临时分支初始化本地分支） 

### 3.8. Git diff 

把本地的代码和index中的代码进行比较，或者是把index中的代码和本地仓库中的代码进行比较。 
1） Git diff 
比较工作目录和Index中的代码。 
2） Git diff - - cached 
比较index和本地仓库中的代码。 

### 3.9. Git checkout 

#### 3.9.1. 切换到分支 

1) 创建一个新分支，并切换到该分支上 
    Git checkout –b 新分支名 
2）切换到某个已经建立的本地分支local_branch 
    Git checkout local_branch 
（使用cat .git/HEAD后，显示refs:refs/heads/ local_branch） 
3) 切换到服务器上的某个分支remote_branch 
    Git checkout remote_branch 
（远程分支remote_branch可以通过 git branch –r 列出） 
4) 切换到某个commit id 
    Git checkout commit_id 
（使用cat .git/HEAD后，显示commit_id） 
5) 切换到某个tag 
    Git checkout tag 
（使用cat .git/HEAD后，显示tag） 
注意： 除了1）和2）外，其余三种都只是切换到了一个临时的( no branch )状态 （this head is detached），这时用 git branch 可以看到处于（no branch）上， cat .git/HEAD 看到指向相应的commit id。 这个（no branch）只是临时存在的，并不是一个真正建立的branch。 如果此时执行2），则这个（no branch）就自动消失了；如果执行1）， 则创建新分支 new branch，并把这个(no branch)挂到这个新分支上，此时cat .git/refs/heads/new_branch 可以看到已经指向了刚才那个commit id。 

#### 3.9.2. 用已有分支初始化新分支 

执行下面的命令，在切换到某个已经建立的local branch或者某个remote branch或者某个commit id 或者某个tag的同时，创建新分支new_branch，并且挂到这个新分支上。 
1） 切换到某个已经建立的本地分支local_branch，并且使用此分支初始化一个新分支new_branch。 
    git checkout –b new_branch local_branch 
2) 切换到某个远程分支remote_branch，并且用此分支初始化一个新分支new_branch。 
    Git checkout –b new_branch remote_branch 
3) 切换到某个commit id，并建立新分支new_branch 
    Git checkout –b new_branch commit_id 
4) 切换到某个tag，并建立新分支new_branch 
    Git checkout –b new_branch tag 

#### 3.9.3. 还原代码 

例如 “git checkout app/model/user.rb” 就会将user.rb文件从上一个已提交的版本中更新回来，未提交的工作目录中的内容全部会被覆盖。

### 3.10. Git-ls-files 

查看当前的git库中有那些文件。 

### 3.11. Git mv 

重命名一个文件、目录或者链接。 
例如：Git mv helloworld.c helloworld1.c （把文件helloworld.c 重命名为 helloworld1.c） 

### 3.12. Git branch 

#### 3.12.1. 总述 

在 git 版本库中创建分支的成本几乎为零，所以，不必吝啬多创建几个分支。当第一次执行git init时，系统就会创建一个名为“master”的分支。 而其它分支则通过手工创建。 
下面列举一些常见的分支策略： 
创建一个属于自己的个人工作分支，以避免对主分支 master 造成太多的干扰，也方便与他人交流协作； 
当进行高风险的工作时，创建一个试验性的分支； 
合并别人的工作的时候，最好是创建一个临时的分支用来合并，合并完成后再“fetch”到自己的分支。 
对分支进行增、删、查等操作。 
注意：分支信息一般在.git/refs/目录下，其中heads目录下为本地分支，remotes为对应服务器上的分支，tags为标签。 

#### 3.12.2. 查看分支 

​    git branch 列出本地git库中的所有分支。在列出的分支中，若分支名前有*，则表示此分支为当前分支。 
​    git branch –r 列出服务器git库的所有分支。 
（可以继续使用命令 “ git checkout -b 本地分支名 服务器分支名”来获取服务器上某个分支的代码文件）。 

#### 3.12.3. 查看当前在哪个分支上 

​    cat .git/HEAD 

#### 3.12.4. 创建一个分支 

1） git branch 分支名 
虽然创建了分支，但是不会将当前工作分支切换到新创建的分支上，因此，还需要命令“git checkout 分支名” 来切换， 
2） git checout –b 分支名 
不但创建了分支，还将当前工作分支切换到了该分支上。 

#### 3.12.5. 切换到某个分支：git checkout 分支名 

切换到主分支：git checkout master 

#### 3.12.6. 删除分支 

​    git branch –D 分支名 
注意： 删除后，发生在该分支的所有变化都无法恢复。强制删除此分支。 

#### 3.12.7. 比较两个分支上的文件的区别 

​    git diff master 分支名 （比较主分支和另一个分支的区别） 

#### 3.12.8. 查看分支历史 

​    git-show-branch （查看当前分支的提交注释及信息） 
​    git-show-branch -all（查看所有分支的提交注释及信息）例如： 
\* [dev] d2 
! [master] m2 
\-- 
\* [dev] d2 
\* [dev^] d1 
\* [dev~2] d0 
*+ [master] m2 
在上述例子中， “--”之上的两行表示有两个分支dev和master， 且dev分支上最后一次提交的日志是“d2”,master分支上最后一次提交的日志是 “m2”。 “--”之下的几行表示了分支演化的历史，其中 dev表示发生在dev分支上的最后一次提交，dev^表示发生在dev分支上的倒数第二次提交。dev~2表示发生在dev分支上的倒数第三次提交。 

#### 3.12.9. 查看当前分支的操作记录 

​    git whatchanged 

#### 3.12.10. 合并分支 

法一： 
    git merge “注释” 合并的目标分支 合并的来源分支 
如果合并有冲突，git会有提示。 
例如：git checkout master  （切换到master分支） 
    git merge HEAD dev~2 (合并master分支和dev~2分支)或者：git merge master dev~2 
法二： 
    git pull 合并的目标分支 合并的来源分支 
例如: git checkout master （切换到master分支） 
    git pull . dev~2（合并当前分支和dev~2分支） 



## 4. Git服务器操作命令（与服务器交互） 

### 4.1. Git clone 

取出服务器的仓库的代码到本地建立的目录中（与服务器交互） 
通过git clone获取远端git库后，.git/config中的开发者信息不会被一起clone过来。仍然需要为本地库的.git/config文件添加开发者信息。此外，开发者还需要自己添加  . gitignore文件。 
通过git clone获取的远端git库，只包含了远端git库的当前工作分支。如果想获取其它分支信息，需要使用 “git branch –r” 来查看， 如果需要将远程的其它分支代码也获取过来，可以使用命令 “ git checkout -b 本地分支名 远程分支名”，其中，远程分支名为 “git branch –r” 所列出的分支名， 一般是诸如“origin/分支名”的样子。如果本地分支名已经存在， 则不需要“-b”参数。  

### 4.2. Git pull 

从服务器的仓库中获取代码，和本地代码合并。（与服务器交互，从服务器上下载最新代码，等同于： Git fetch + Git merge） 
从其它的版本库（既可以是远程的也可以是本地的）将代码更新到本地，例如：“git pull origin master ”就是将origin这个版本库的代码更新到本地的master主分支。 
    git pull可以从任意一个git库获取某个分支的内容。用法如下： 
git pull username@ipaddr:远端repository名远端分支名 本地分支名。这条命令将从远端git库的远端分支名获取到本地git库的一个本地分支中。其中，如果不写本地分支名，则默认pull到本地当前分支。 
需要注意的是，git pull也可以用来合并分支。 和git merge的作用相同。 因此，如果你的本地分支已经有内容，则git pull会合并这些文件，如果有冲突会报警。 

### 4.3. Git push 

将本地commit的代码更新到远程版本库中，例如 “git push origin”就会将本地的代码更新到名为orgin的远程版本库中。 
    git push和git pull正好想反，是将本地某个分支的内容提交到远端某个分支上。用法： git pushusername@ipaddr:远端repository名本地分支名 远端分支名。这条命令将本地git库的一个本地分支push到远端git库的远端分支名中。 
需要格外注意的是，git push好像不会自动合并文件。因此，如果git push时，发生了冲突，就会被后push的文件内容强行覆盖，而且没有什么提示。 这在合作开发时是很危险的事情。  

### 4.4. Git fetch 

从服务器的仓库中下载代码。（与服务器交互，从服务器上下载最新代码） 
相当于从远程获取最新版本到本地，不会自动merge，比Git pull更安全些。 
使用此方法来获取服务器上的更新。 
例如：如果使用git checkout nov/eclair_rocket （nov/eclair_rocket为服务器上的分支名），则是获取上次使用git fetch命令时从服务器上下载的代码；如果先使用 git fetch ，再使用git checkout nov/eclair_rocket，则是先从服务器上获取最新的更新信息，然后从服务器上下载最新的代码。



# 六、Git与Github连接

```SHELL
#首先使用以下命令来进行公钥生成
ssh-keygen -t rsa -C "YOUR_EMAIL_ADDRESS"
```

生成公钥之后在github绑定公钥，公钥生成位置为

```shell
~/yzk/.ssh/id_rsa.pub
```

之后使用ssh进行连接验证是否连接已经绑定好

```shell
ssh -T git@github.com
```

如果出现successfully authenticated则说明连接成功。

之后只需要在不同的目录建立本地仓库，绑定不同的远程仓库，分别进入到各个本地仓库中进行push即可

# 七、Linux下格式化u盘

```shell
fdisk -l #查看U盘加载文件 是/dev/sdc4
```

先卸载掉

```shell
umount /dev/sdd1
```

开始格式化 

```shell
sudo mkfs -t vfat /dev/sdd1
```



# 八、Linux下关闭笔记本自带键盘

```shell
sudo xinput list 
```

找到 AT Translated Set 2 keyboard，记下id号

```shell
xinput set-prop xx "Device Enabled" 0 	#xx为id
```

要重新打开则将0设置为1即可。

# 九、清空回收站

```shell
sudo rm -rf ~/.local/share/Trash/*
```

# 十、设置自定义命令

使用alias命令即可，语法

```shell
alias 别名="命令"
```

注意：等号左右不能有空格，命令中若是带有双引号，外部可以使用单引号。