**在使用分布式系统前，应该尽可能的在单机上多做尝试，能用单机解决的问题就不要使用分布式系统。**

# 第一节

使用分布式系统的原因：高性能、可容错、物理上分布、安全、隔离

分布式系统的挑战：并法控制，局部故障、需要精心设计才可以发挥想要的性能

存储、通信、计算系统(MapReduce)。存储是重点

希望能够构建外观和行为类似于非分布式存储和计算系统的接口

RPC、线程、并发

1. 可扩展性--两倍的计算机或资源能使我获得两倍的性能或吞吐量，但是不是无限制的提升，数据库会成为最终的瓶颈。

2. 容错--大规模让本来不用担心的小概率事件变成了一个常见问题，分布式系统要求能够自动处理这些问题，并返回对应的处理结果。

   ​	可用性：出现一些故障后仍可以进行工作。

   ​	可恢复性：停止响应后，进行修复可以继续运行。

容错系统中，始终优先访问主服务器

3. 一致性--强一致性，有理由保证能够看到最新的一致性，但必须与他人进行大量的通信，代价很大，费时间；弱一致性，避免强一致性的代价，但可能获取到未更新的数据。

## MapReduce

谷歌设计的系统，该系统会将所有的输入传入map函数进行处理，生成K/V列表进行输出，然后进行reduce，以key为单位将这些map收集到一起，输入到不同的reduce中进行处理。整个计算流程被称为job，任何一次Map/Reduce的调用被称为Task（MapTask/ReduceTask）。

```
//分类
Map(k,v)
	split v into work
	for each word w
		emit(w,"1")
```

```
//统计
Reduce(k,v)
	emit(len(v))
```



​		一个job的输出可以作为下一个job的输入

​		在worker机器上运行这些map，将数据存储在worker的硬盘中，在运行reduce之前会将所有的worker进行通信，获取所有相关的key，再进行reduce，输出结果将存储在谷歌文件集群服务器（GFS）的一个文件中。GFS实际上与worker在同一个服务器集群上，即服务器上两者都有部署。

GFS(Google File System)会自动地将存储在上面的任何大文件分割为很多64MBit（默认）大小的数据块，并将他们分散存储在许多服务器上，并保存两到三个副本。

​	输入通过网络与正确的GFS服务器进行通信或者可能是存储部分输入内容到GFS并通过网络将其获取到worker服务器中进行map操作。

需要很大的网络吞吐量，这是一个瓶颈。需要尽量避免使用网络，所以他们将GFS和worker部署在统一台服务器上。

其中一种方案：将GFS服务器和MapReduce Worker运行在同一组计算机集群中，mastet将map任务拆分，分布到worker，当master需要某个输入时，会去GFS服务器上寻找，并使用MapReduce软件来执行该输入文件所对应的map操作。这样传输数据速度就不会受到网络限制，只有磁盘读写速度的限制。

在MapReduce中将给定key对应的所有这些值组合到一起后，传给Reduce以供调用，这里就需要网络通信。

key的组合过程（shuffle）最初是按行移动存储的，并且与运行map同在一个机器上，需要将其转换成按列存储，以供Reduce使用。

MapReduce是批处理方式，现代系统通常会使用流处理来代替批处理。

# 第二节

Go语言中，线程为Goroutin

多线程：并发I/O，同一时间会存在多个活动I/O

​				多核并行